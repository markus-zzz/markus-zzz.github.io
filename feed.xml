<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="https://www.zzzconsulting.se/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.zzzconsulting.se/" rel="alternate" type="text/html" /><updated>2018-10-14T11:16:43+02:00</updated><id>https://www.zzzconsulting.se/</id><title type="html">ZZZ-Consulting</title><subtitle>Consulting services offered in the fields of Compiler engineering, Graphics programming and Embedded computing.</subtitle><entry><title type="html">Building a modem - part 2</title><link href="https://www.zzzconsulting.se/2018/08/11/build-a-modem-part-2.html" rel="alternate" type="text/html" title="Building a modem - part 2" /><published>2018-08-11T00:00:00+02:00</published><updated>2018-08-11T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/08/11/build-a-modem-part-2</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/08/11/build-a-modem-part-2.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In this post we return to our modem building project to checkup on the
progress.&lt;/p&gt;

&lt;p&gt;The code corresponding to the progress of this post is available as branch
&lt;a href=&quot;https://github.com/markus-zzz/modem/tree/part-2&quot;&gt;part-2&lt;/a&gt; of the modem GitHub
repository.&lt;/p&gt;

&lt;h3 id=&quot;hardware-blocks&quot;&gt;Hardware blocks&lt;/h3&gt;
&lt;p&gt;The current implementation exposes two AXI mapped ring buffers, and some
control register, using the address map from the &lt;a href=&quot;/2018/08/03/build-a-modem-part-1.html&quot;&gt;previous
post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Each ring buffer is currently implemented using a dual ported synchronous SRAM
block with one port being tied to the AXI and the other to the internal data
path of the modem.&lt;/p&gt;

&lt;p&gt;Now dual ported memories are large and expensive and for the modest data rates
we plan to put on these memories we can certainly get a way both AXI and
internal data path sharing the single port on a single ported memory. Doing so
is of course not free and it will be at the expense of some increased
implementation complexity but that we can handle later. So in other words, for
now dual ported is good since they allow for slightly simpler implementation
but we should eventually switch to using single ported.&lt;/p&gt;

&lt;p&gt;Either way, dual ported or not, Synchronous SRAM blocks have one slightly
annoying property with respect to reads and that is that the read address is
clocked. That is the behavioural model looks like this&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // read operation
    always @(posedge rclk) begin
        if (rce) begin
            ra &amp;lt;= raddr;
        end
    end

    assign do = mem[ra];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In other words you cannot simply present the read address (&lt;em&gt;raddr&lt;/em&gt;) and expect
to latch the data (&lt;em&gt;do&lt;/em&gt;) at the next rising clock edge but instead you have to
wait an additional cycle. Of course it is all pretty obvious when you think
about it (they are called synchronous for a reason) but I for one tend to
forget this ever so often.&lt;/p&gt;

&lt;p&gt;One place where this shows up is in the AXI read channel response logic in
&lt;a href=&quot;https://github.com/markus-zzz/modem/blob/part-2/rtl/verilog/modem_axi_slave.v&quot;&gt;rtl/verilog/modem_axi_slave.v&lt;/a&gt;
since we have to delay the read response for ring buffer reads by one cycle
compared to if it was a register read.&lt;/p&gt;

&lt;p&gt;Another thing that slightly complicates matters is that we cannot simply drain
the TX ring buffer at constant full speed but instead need to repeatedly do
stop and go to avoid overflowing the internal data path as it operates at a
much lower speed (one byte is several symbols, one symbol is several samples,
etc, etc).&lt;/p&gt;

&lt;p&gt;To deal with this we need a &lt;em&gt;handshake&lt;/em&gt; mechanism, and we have chosen to do one
using two signals, &lt;em&gt;valid&lt;/em&gt; and &lt;em&gt;ready&lt;/em&gt;, as follows.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Producer asserts &lt;em&gt;valid&lt;/em&gt; when valid data is output&lt;/li&gt;
  &lt;li&gt;Consumer asserts &lt;em&gt;ready&lt;/em&gt; when it can accept data&lt;/li&gt;
  &lt;li&gt;The transaction occurs on a rising clock edge when both &lt;em&gt;ready&lt;/em&gt; and &lt;em&gt;valid&lt;/em&gt;
are sampled high&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Right now the TX and RX ring buffers are tied together in loop-back mode with
the silly action of transforming lower-case letters to upper-case and vice
versa.&lt;/p&gt;

&lt;p&gt;An interrupt pulse is generated when the hardware updates the read pointer of
the TX ring and the write pointer of the RX ring.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://github.com/markus-zzz/modem/blob/part-2/rtl/verilog/modem_axi_top.v&quot;&gt;rtl/verilog/modem_axi_top.v&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;tx-ctrl&quot;&gt;TX-Ctrl&lt;/h4&gt;
&lt;p&gt;This is the controller for the transmit ring buffer. It is basically a state
machine that sits around waiting for the read pointer to be become unequal the
write pointer (indicating that the buffer is no longer empty) and then starts
reading words.&lt;/p&gt;

&lt;p&gt;The fact that the internal data path needs to be fed with bytes, the pipelined
read behaviour of the memory and the presence of flow control slightly
complicates things. This in combination with the long term ambition to switch
to a single ported memory results in the current simple design, with perhaps a
seemingly abundant number of states.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://github.com/markus-zzz/modem/blob/part-2/rtl/verilog/tx_ctrl.v&quot;&gt;rtl/verilog/tx_ctrl.v&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;rx-ctrl&quot;&gt;RX-Ctrl&lt;/h4&gt;
&lt;p&gt;This is the controller for the receive ring buffer. It is quite similar to its
transmit counterpart although it operates in the opposite direction and as a
result does not have to deal with the issues of memory reads.&lt;/p&gt;

&lt;p&gt;One thing we do have to deal with here however is the detection of overflows,
but that is rather straight forward and we simply skip writing the message
header and advancing the write pointer when this condition is detected.
Eventually we should set a status bit indicating the overflow in the header of
the next message written to the ring and have the device driver informing
user-space somehow (perhaps by one &lt;em&gt;read&lt;/em&gt; returning &lt;em&gt;EOVERFLOW&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://github.com/markus-zzz/modem/blob/part-2/rtl/verilog/rx_ctrl.v&quot;&gt;rtl/verilog/rx_ctrl.v&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;linux-device-driver&quot;&gt;Linux device driver&lt;/h3&gt;
&lt;p&gt;The current device driver resembles the one from the I2C series quite a lot. A
&lt;em&gt;read&lt;/em&gt; operation will block if the RX ring is empty and a &lt;em&gt;write&lt;/em&gt; operation
will block if the TX ring has insufficient space left for the message. In
either case the sleeping process will be awoken by previously mentioned
interrupt pulse (indicating that the HW has updated its pointers).&lt;/p&gt;

&lt;p&gt;This implementation seems to work for now but later on should probably add
mutexes to protect the ring buffers from concurrent access (i.e. many processes
doing &lt;em&gt;read&lt;/em&gt; at the same time and similarly for &lt;em&gt;write&lt;/em&gt;). Not sure if that
use-case make a ton of sense though but we should properly handle that
situation anyway.&lt;/p&gt;

&lt;p&gt;Also we would likely benefit from a more fine grained interrupt control, being
able to see if the source was RX or TX and being able to mask.&lt;/p&gt;

&lt;p&gt;For details see
&lt;a href=&quot;https://github.com/markus-zzz/modem/blob/part-2/linux/zzz-modem-driver.c&quot;&gt;linux/zzz-modem-driver.c&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;try-it-out&quot;&gt;Try it out!&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/markus-zzz/modem.git
cd modem
git checkout part-2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;As a sanity check run the simple standalone test transmitting a sequence of
test messages from size 4 to size 16&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./build-all.sh &amp;amp;&amp;amp; ./run-all.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;After that we can move on to do testing with QEMU and the Linux device driver.
The steps for setting this up are almost identical to what was described in the
I2C controller series (especially &lt;a href=&quot;/2018/07/18/i2c-controller-part-2.html&quot;&gt;part-2&lt;/a&gt; and &lt;a href=&quot;/2018/07/27/i2c-controller-part-4.html&quot;&gt;part-4&lt;/a&gt;) so repetion here will be brief.&lt;/p&gt;

&lt;p&gt;Modify the Linux device tree for our modem device&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/arch/arm/boot/dts/vexpress-v2m.dtsi b/arch/arm/boot/dts/vexpress-v2m.dtsi
index b0021a8..2279196 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/arch/arm/boot/dts/vexpress-v2m.dtsi
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/arch/arm/boot/dts/vexpress-v2m.dtsi
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -179,8 +179,8 @@
&lt;/span&gt;                                clock-names = &quot;uartclk&quot;, &quot;apb_pclk&quot;;
                        };

&lt;span class=&quot;gd&quot;&gt;-                       v2m_serial3: uart@c000 {
-                               compatible = &quot;arm,pl011&quot;, &quot;arm,primecell&quot;;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+                       zzz_modem: zzz_modem@c000 {
+                               compatible = &quot;zzz-modem&quot;;
&lt;/span&gt;                                reg = &amp;lt;0x0c000 0x1000&amp;gt;;
                                interrupts = &amp;lt;8&amp;gt;;
                                clocks = &amp;lt;&amp;amp;v2m_oscclk2&amp;gt;, &amp;lt;&amp;amp;smbclk&amp;gt;;
&lt;span class=&quot;gh&quot;&gt;diff --git a/arch/arm/boot/dts/vexpress-v2p-ca9.dts b/arch/arm/boot/dts/vexpress-v2p-ca9.dts
index 5814460..98206c0 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/arch/arm/boot/dts/vexpress-v2p-ca9.dts
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/arch/arm/boot/dts/vexpress-v2p-ca9.dts
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -25,7 +25,6 @@
&lt;/span&gt;                serial0 = &amp;amp;v2m_serial0;
                serial1 = &amp;amp;v2m_serial1;
                serial2 = &amp;amp;v2m_serial2;
&lt;span class=&quot;gd&quot;&gt;-               serial3 = &amp;amp;v2m_serial3;
&lt;/span&gt;                i2c0 = &amp;amp;v2m_i2c_dvi;
                i2c1 = &amp;amp;v2m_i2c_pcie;
        };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;For QEMU we need to be using
&lt;a href=&quot;https://github.com/markus-zzz/modem/blob/part-2/qemu/axi_master_client_device.c&quot;&gt;qemu/axi_master_client_device.c&lt;/a&gt;
and not the corresponding file from the previous repository.&lt;/p&gt;

&lt;p&gt;Once everything is built and moved to the proper places the RTL simulation is
started with&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vvp -M. -mvpi_axi_master modem.vvp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and QEMU as before. Watch Linux boot, then login, install the module and do the
following&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat /dev/zzz-modem &amp;gt; rx.txt &amp;amp;
echo &quot;Hello World!&quot; &amp;gt; /dev/zzz-modem
cat rx.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And to transmit some more messages of varying length&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for i in $(seq 100); do echo &quot;Hello $(seq -s &quot; &quot; $i)&quot; &amp;gt; /dev/zzz-modem; done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;what-is-next&quot;&gt;What is next?&lt;/h3&gt;

&lt;p&gt;Right now we have implemented the loop-back at the highest level possible, i.e.
right after the ring buffers. This is nice, in my opinion, since it allows for
easy testing with the &lt;em&gt;/dev/zzz-modem&lt;/em&gt; device node right away and gives us more
time to flush out any annoying bugs in the HW/SW interface.&lt;/p&gt;

&lt;p&gt;Since our implementation strategy is to go top down we will continue to do so
and keep on moving the loop-back loop further down the stack as more layers are
added.&lt;/p&gt;

&lt;p&gt;Currently I imagine that the following milestones will be useful&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Next have loop-back of IQ symbols&lt;/li&gt;
  &lt;li&gt;Then loop-back of sampled pulse shaped IQ symbols&lt;/li&gt;
  &lt;li&gt;Then introduce a shift so that we need to do synchronization in RX&lt;/li&gt;
  &lt;li&gt;Do the same thing as previous step but use passband instead of baseband&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;Finally, a physical audio loop-back wire on the ZedBoard&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That is it for this post. Questions or feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction In this post we return to our modem building project to checkup on the progress.</summary></entry><entry><title type="html">MyCC - an introduction</title><link href="https://www.zzzconsulting.se/2018/08/04/mycc-an-introduction.html" rel="alternate" type="text/html" title="MyCC - an introduction" /><published>2018-08-04T00:00:00+02:00</published><updated>2018-08-04T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/08/04/mycc-an-introduction</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/08/04/mycc-an-introduction.html">&lt;p&gt;Today we will be looking at a prototype toy C compiler that I have been working
on every now and then for a while. Of course it is nowhere near complete nor
even useful for any particular purpose at all besides perhaps my own amusement
and possibly that of others.&lt;/p&gt;

&lt;p&gt;Still I think that it serves as a meaningful exercise to start from a clean
slate every now and then and do things the way that you feel are right (which
may be the simplest or most naive way possible) and not being burdened by any
particular framework.&lt;/p&gt;

&lt;p&gt;Say for instance that you read this really interesting article about
implementing a SSA based register allocator and now you want to try it out. So
you turn to a well established compiler framework like LLVM or GCC. Okay, so
the code base is huge and the compiler build time is insane and you just wanted
to play around a bit. Clearly that situation is not ideal and at these times a
much much simpler and smaller framework would be useful. Preferably one that
still preserves some of the good ideas from the larger ones.&lt;/p&gt;

&lt;p&gt;Now I do not want to bash on big compiler frameworks (looking your way LLVM)
but the fact remains that these huge frameworks are not suitable for every
possible purpose and depending on what your intended purpose is they may in
fact make things a lot more complicated than they need to be.&lt;/p&gt;

&lt;h2 id=&quot;mycc&quot;&gt;MyCC&lt;/h2&gt;

&lt;p&gt;The design of MyCC borrows heavily from LLVM. One of the best things about LLVM
is the use of a very well defined intermediate representation in the middle
end. This LLVM IR is linearised and resembles assembly language so much that
they in fact call it &lt;a href=&quot;https://llvm.org/docs/LangRef.html&quot;&gt;the LLVM Assembly
Language&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As stated in that document one of the design criteria for the LLVM IR was to
represents well both in graph form in compiler memory as well as in human
readable textual form in dump files. The importance of the latter cannot be
overstated.&lt;/p&gt;

&lt;p&gt;While a well defined IR allows us to import and export the entire compilation
state between passes it also allows us to create a virtual machine that can
execute this IR. Together these two provide for the development of some very
powerful testing tool.&lt;/p&gt;

&lt;h2 id=&quot;preparations&quot;&gt;Preparations&lt;/h2&gt;
&lt;p&gt;To acquire the code base and build the compiler follow these steps. Note that
the compiler build time for a full debug build is just a second or two (which
is hardly surprising since there is so little code and it is not C++).&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ZZZ_ROOT=some/path
cd $ZZZ_ROOT
git clone https://github.com/markus-zzz/mycc.git
mkdir $ZZZ_ROOT/mycc/build
cd $ZZZ_ROOT/mycc/build
make -f $ZZZ_ROOT/mycc/src/Makefile -j8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Next we run the test suite by executing the following commands.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT/mycc/test
./runner.pl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now what just happened here is actually quite interesting so let’s look into
that. If we enforce the convention that each of our tests shall return a 32 bit
integer as its result (and preferably not just &lt;em&gt;true&lt;/em&gt;/&lt;em&gt;false&lt;/em&gt; as that would
increase the risk of falsely indicating that a test passes due to a miscompile)
we can do the following.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Use a reference compiler (e.g. gcc) to produce a known good value&lt;/li&gt;
  &lt;li&gt;Use the IR simulator to verify that the IR simulates to the same good value
after each pass&lt;/li&gt;
  &lt;li&gt;Verify that the final executable produces the good value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course this testing is not immune to all kind of problems but I would argue
that it provides a pretty good coverage for rather little effort once you have
the basic machinery in place. To add a new test, simply add a well defined C
code snippet that produces an integer as result.&lt;/p&gt;

&lt;h2 id=&quot;a-tour-down-the-compilation-pipeline&quot;&gt;A tour down the compilation pipeline&lt;/h2&gt;
&lt;p&gt;Let us take a look at a simple example and see how the code gets transformed as
we move further down the compilation pipeline. Consider something simple such
as &lt;em&gt;dot.c&lt;/em&gt; given below&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int dot(int *a, int *b, int len)
{
	int i;
	int sum = 0;
	for (i = 0; i &amp;lt; len; i = i + 1) {
		sum = sum + a[i] * b[i];
	}

	return sum;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Begin by invoking the compiler driver as in&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./build/driver --dump-all dot.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;doing so should produce a set of dump files where the intermediate
representation at the given stage is dumped. These files are very important for
debugging since they often times allow you to pinpoint at what stage things go
wrong&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zzzconsulting.se/download/mycc-an-introduction/ast_00_pristine.txt&quot;&gt;ast_00_pristine.txt&lt;/a&gt; -
When the front end parses the input code it produces an Abstract Syntax Tree
(AST). This representation is extremely verbose and essentially contains an AST
node for each grammar rule applied.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zzzconsulting.se/download/mycc-an-introduction/ir_00_pristine.txt&quot;&gt;ir_00_pristine.txt&lt;/a&gt; -
Middle end Intermediate Representation (what we simply call IR) immediately
after being translated from AST.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zzzconsulting.se/download/mycc-an-introduction/ir_01_mem2reg.txt&quot;&gt;ir_01_mem2reg.txt&lt;/a&gt; -
IR after applying the &lt;em&gt;mem2reg&lt;/em&gt; optimization pass.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zzzconsulting.se/download/mycc-an-introduction/cg_00_iselect.txt&quot;&gt;cg_00_iselect.txt&lt;/a&gt; -
Code Generator intermediate representation after selecting machine instructions
for the middle end IR. Note that this IR is using virtual registers and is
still in SSA form.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zzzconsulting.se/download/mycc-an-introduction/cg_01_regalloc.txt&quot;&gt;cg_01_regalloc.txt&lt;/a&gt; -
Machine instructions after allocating physical registers.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zzzconsulting.se/download/mycc-an-introduction/cg_02_branch_predication.txt&quot;&gt;cg_02_branch_predication.txt&lt;/a&gt; -
Machine instructions after performing branch predication optimization pass.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h2&gt;
&lt;p&gt;That is it for this post. When we return to MyCC in a later post I intend to
write about the implementation of its SSA based register allocator.&lt;/p&gt;</content><author><name></name></author><summary type="html">Today we will be looking at a prototype toy C compiler that I have been working on every now and then for a while. Of course it is nowhere near complete nor even useful for any particular purpose at all besides perhaps my own amusement and possibly that of others.</summary></entry><entry><title type="html">Building a modem - part 1</title><link href="https://www.zzzconsulting.se/2018/08/03/build-a-modem-part-1.html" rel="alternate" type="text/html" title="Building a modem - part 1" /><published>2018-08-03T00:00:00+02:00</published><updated>2018-08-03T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/08/03/build-a-modem-part-1</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/08/03/build-a-modem-part-1.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;This is the first post of a new series where we are going to attempt the build
a simple modem. In other words we will try to build a digital communications
link where the sender modulates a communication message, a stream of bytes, to
make it suitable for transmission over a given media and the receiver
demodulates to recover the original message.&lt;/p&gt;

&lt;p&gt;Since your author is no expert (to put it mildly) in the fields of
&lt;em&gt;communications theory&lt;/em&gt; or &lt;em&gt;signal processing&lt;/em&gt; this post series will not focus
on the theoretical details of that but instead refer to the excellent
presentation of those matters over at &lt;a href=&quot;http://dspillustrations.com&quot;&gt;DSP
Illustrations&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I envision the complete system to run on a &lt;a href=&quot;http://zedboard.org/&quot;&gt;ZedBoard&lt;/a&gt; (or
actually two to make it more interesting) and use the onboard audio codec (i.e.
sound waves in the range 20Hz-20kHz) as the transmission media. However the
actual hardware is not really important to follow along as we will rely
extensively on a QEMU / RTL simulation environment.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;p&gt;Let’s begin by presenting an overview.&lt;/p&gt;

&lt;h3 id=&quot;linux-device-driver&quot;&gt;Linux device driver&lt;/h3&gt;
&lt;p&gt;A Linux device driver presents the device node &lt;em&gt;/dev/zzzmodem&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;write&lt;/em&gt; - queues a message for transmission. A single call to &lt;em&gt;write&lt;/em&gt; results
in a single message queued.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;read&lt;/em&gt; - returns a received message. A call to &lt;em&gt;read&lt;/em&gt; returns a single
received message (i.e. the buffer size given must be equal to the maximal
transmission unit (MTU)).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since the &lt;em&gt;read&lt;/em&gt;/&lt;em&gt;write&lt;/em&gt; interface is based on complete messages the driver
should allow for multiple processes to &lt;em&gt;read&lt;/em&gt; and &lt;em&gt;write&lt;/em&gt; at the same time.&lt;/p&gt;

&lt;h3 id=&quot;modem-block-memory-mapped-interface&quot;&gt;Modem block memory mapped interface&lt;/h3&gt;
&lt;p&gt;The modem block exposes two ring buffers in its address map. One for
transmitting (TX) and one for receiving (RX), each of them are accompanied with
read and write pointers.&lt;/p&gt;

&lt;p&gt;For TX a device driver &lt;em&gt;write&lt;/em&gt; will result in one full message being put in
the TX ring buffer. If there is no room then the driver will put the writing
process to sleep. The read pointer updates in one go as the entire message is
sent. An interrupt can be generated whenever the read pointer updates.&lt;/p&gt;

&lt;p&gt;For RX a device driver &lt;em&gt;read&lt;/em&gt; will result in one full message being lifted from
the RX ring buffer. If there are no message to lift then the calling process
will be put to sleep. An interrupt can be generated when the write pointer
updates. The write pointer will only be updated when a full message is put in
the buffer. If the buffer overruns a counter will be incremented and possibly
interrupt generated.&lt;/p&gt;

&lt;p&gt;Everything is 32 bit aligned inside the ring buffers. A message begins with a
32 bit header indicating the length of the message. The next message in the
ring buffer will begin (i.e. have its header) at this offset but aligned to a
32 bit boundary.&lt;/p&gt;

&lt;p&gt;The following suggested address map of our modem device provides the essentials
and fits well in 4KiB (i.e. 0x1000 bytes).&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Begin&lt;/th&gt;
      &lt;th&gt;End&lt;/th&gt;
      &lt;th&gt;Access&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0x000&lt;/td&gt;
      &lt;td&gt;0x3ff&lt;/td&gt;
      &lt;td&gt;W&lt;/td&gt;
      &lt;td&gt;TX ring buffer (1 KiB)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x400&lt;/td&gt;
      &lt;td&gt;0x7ff&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;RX ring buffer (1 KiB)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x800&lt;/td&gt;
      &lt;td&gt;0x803&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;TX read pointer&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x804&lt;/td&gt;
      &lt;td&gt;0x807&lt;/td&gt;
      &lt;td&gt;R/W&lt;/td&gt;
      &lt;td&gt;TX write pointer&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x808&lt;/td&gt;
      &lt;td&gt;0x80b&lt;/td&gt;
      &lt;td&gt;R/W&lt;/td&gt;
      &lt;td&gt;RX read pointer&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x80c&lt;/td&gt;
      &lt;td&gt;0x80f&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;RX write pointer&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Access permissions are what one would expect, that is software cannot write to
registers/memory owned by the modem block. All registers should be readable by
software though to ease debugging. Writes to a read-only address are simply
ignored.&lt;/p&gt;

&lt;h3 id=&quot;signal-processing&quot;&gt;Signal processing&lt;/h3&gt;
&lt;p&gt;The modulation of choice for our modem will be Quadrature Phase Shift Keying
(QPSK), meaning that each &lt;em&gt;symbol&lt;/em&gt; will convey two data bits. A &lt;em&gt;symbol mapper&lt;/em&gt;
will take care of the straight forward task of turning our byte stream message
into a stream of QPSK symbols. For these symbols we then intend to apply the
signal processing chain described
&lt;a href=&quot;http://dspillustrations.com/pages/posts/misc/baseband-up-and-downconversion-and-iq-modulation.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Of course a lot more needs to be said about that and we will constantly return
to this topic as needed. For now though, for the purpose of an overview, this
should be enough.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;
&lt;p&gt;As there is certainly no shortage of work to be done for this project how do we
decide what to do first?&lt;/p&gt;

&lt;p&gt;Well, let us approach this from the top down so I say let’s begin with the ring
buffers and their software interface.&lt;/p&gt;

&lt;p&gt;To quickly have something that is testable we can set our first goal as
follows: Implement RX and TX ring buffers and tie them together in loop back
mode with some silly action like transforming lowercase letters to uppercase.&lt;/p&gt;

&lt;p&gt;Having those parts in place early will hopefully allow us to develop a more
sophisticated testing framework that will come in handy later on when we
approach the more mathematical areas further down the pipe. As well as giving
us additional mileage on our perhaps mundane but oh so error prone byte
shoveling machinery.&lt;/p&gt;

&lt;p&gt;That’s it for this post! When we return in the next post we will look into the
details of implementing the ‘byte shoveling machinery’.&lt;/p&gt;

&lt;p&gt;Until then, as usual, if there are questions or feedback - leave a comment
below!&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction This is the first post of a new series where we are going to attempt the build a simple modem. In other words we will try to build a digital communications link where the sender modulates a communication message, a stream of bytes, to make it suitable for transmission over a given media and the receiver demodulates to recover the original message.</summary></entry><entry><title type="html">A basic I2C controller - part 4</title><link href="https://www.zzzconsulting.se/2018/07/27/i2c-controller-part-4.html" rel="alternate" type="text/html" title="A basic I2C controller - part 4" /><published>2018-07-27T00:00:00+02:00</published><updated>2018-07-27T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/07/27/i2c-controller-part-4</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/07/27/i2c-controller-part-4.html">&lt;p&gt;Now we are going to revisit the device driver from part 3 of this series and
redo it properly.&lt;/p&gt;

&lt;p&gt;Modern Linux uses something called a &lt;em&gt;device tree&lt;/em&gt; to describe the
configuration of a SoC and as the name suggests this data structure describes
what devices are connected to a system. Among the properties described the
following interest us at this point&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;identifier for a compatible device driver&lt;/li&gt;
  &lt;li&gt;where is this device mapped in memory&lt;/li&gt;
  &lt;li&gt;what interrupt line is this device connected to&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;preparations&quot;&gt;Preparations&lt;/h2&gt;
&lt;p&gt;Since we have chosen to use the ARM VersatileExpress platform for our
experiments we are going to have to modify its &lt;em&gt;device tree&lt;/em&gt; description which
is contained in the files &lt;em&gt;arch/arm/boot/dts/vexpress-v2p-ca9.dts&lt;/em&gt; and
&lt;em&gt;arch/arm/boot/dts/vexpress-v2m.dtsi&lt;/em&gt; (where the former includes the latter).
In fact the former describes the CPU and the latter describes the &lt;em&gt;motherboard&lt;/em&gt;
i.e. the board that contains all the peripherals.&lt;/p&gt;

&lt;p&gt;Since I do not poses a detailed knowledge about this system, for matter such as
what memory regions are available or what interrupt lines are available, the
easiest way forward is going to be to hijack an existing device and reuse its
resources (memory range and interrupt line). Luckily the motherboard has four
UARTs and for our purposes only the first one is needed, so we can safely
borrow the resources from the last one.&lt;/p&gt;

&lt;p&gt;In practise that means that we need to make the following modifications&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/arch/arm/boot/dts/vexpress-v2m.dtsi b/arch/arm/boot/dts/vexpress-v2m.dtsi
index b0021a8..f651956 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/arch/arm/boot/dts/vexpress-v2m.dtsi
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/arch/arm/boot/dts/vexpress-v2m.dtsi
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -179,8 +179,8 @@
&lt;/span&gt;                                clock-names = &quot;uartclk&quot;, &quot;apb_pclk&quot;;
                        };

&lt;span class=&quot;gd&quot;&gt;-                       v2m_serial3: uart@c000 {
-                               compatible = &quot;arm,pl011&quot;, &quot;arm,primecell&quot;;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+                       zzz_i2c_eprom: zzz_i2c_eprom@c000 {
+                               compatible = &quot;zzz-i2c-eprom&quot;;
&lt;/span&gt;                                reg = &amp;lt;0x0c000 0x1000&amp;gt;;
                                interrupts = &amp;lt;8&amp;gt;;
                                clocks = &amp;lt;&amp;amp;v2m_oscclk2&amp;gt;, &amp;lt;&amp;amp;smbclk&amp;gt;;
&lt;span class=&quot;gh&quot;&gt;diff --git a/arch/arm/boot/dts/vexpress-v2p-ca9.dts b/arch/arm/boot/dts/vexpress-v2p-ca9.dts
index 5814460..98206c0 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/arch/arm/boot/dts/vexpress-v2p-ca9.dts
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/arch/arm/boot/dts/vexpress-v2p-ca9.dts
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -25,7 +25,6 @@
&lt;/span&gt;                serial0 = &amp;amp;v2m_serial0;
                serial1 = &amp;amp;v2m_serial1;
                serial2 = &amp;amp;v2m_serial2;
&lt;span class=&quot;gd&quot;&gt;-               serial3 = &amp;amp;v2m_serial3;
&lt;/span&gt;                i2c0 = &amp;amp;v2m_i2c_dvi;
                i2c1 = &amp;amp;v2m_i2c_pcie;
        };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;At this point we can (and should) build Linux and boot to note that it finds
one serial port less. Next let’s turn our attention to QEMU where we apply the
following change&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/hw/arm/vexpress.c b/hw/arm/vexpress.c
index 9fad791..c1f7550 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/hw/arm/vexpress.c
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/hw/arm/vexpress.c
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -625,7 +625,11 @@ static void vexpress_common_init(MachineState *machine)
&lt;/span&gt;     pl011_create(map[VE_UART0], pic[5], serial_hds[0]);
     pl011_create(map[VE_UART1], pic[6], serial_hds[1]);
     pl011_create(map[VE_UART2], pic[7], serial_hds[2]);
&lt;span class=&quot;gi&quot;&gt;+#if 0
&lt;/span&gt;     pl011_create(map[VE_UART3], pic[8], serial_hds[3]);
&lt;span class=&quot;gi&quot;&gt;+#else
&lt;/span&gt;     sysbus_create_simple(&quot;axi_master_client_device&quot;, map[VE_UART3], pic[8]);
&lt;span class=&quot;gi&quot;&gt;+#endif
&lt;/span&gt;
     sysbus_create_simple(&quot;sp804&quot;, map[VE_TIMER01], pic[2]);
     sysbus_create_simple(&quot;sp804&quot;, map[VE_TIMER23], pic[3]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;i.e. we map our device to the same address and interrupt as where the fourth
UART used to be.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;
&lt;p&gt;In RTL the I2C controller has been extended with an IRQ line that asserts
whenever the controller state machine goes from a non-idle state to idle (i.e.
it has just finished work). An AXI mapped register has also been added that,
when written to, de-asserts the IRQ line.&lt;/p&gt;

&lt;p&gt;Since our RTL simulation is not that tightly tied into QEMU (and there is some
delay between a de-assert write and the de-asserted IRQ line finds its way back
into QEMU) we are going to use the IRQ line as &lt;em&gt;edge triggered&lt;/em&gt; to avoid
problems with the ISR falsely triggering.&lt;/p&gt;

&lt;p&gt;After rebuilding QEMU and Linux (as described in previous posts) we can now
focus our attention on the actual device driver
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/linux/i2c-eprom-driver-irq.c&quot;&gt;linux/i2c-eprom-driver-irq.c&lt;/a&gt;.
I would say that it differs from the previous attempt in the following ways&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Registers as a &lt;em&gt;platform driver&lt;/em&gt; and as such only gets called for &lt;em&gt;device
tree&lt;/em&gt; entries that match the given compatibility string&lt;/li&gt;
  &lt;li&gt;Gets the interrupt number and mapped memory range from the &lt;em&gt;device tree&lt;/em&gt; (see
probe function)&lt;/li&gt;
  &lt;li&gt;State machine inside interrupt handler&lt;/li&gt;
  &lt;li&gt;Wait queues to block user process while waiting for a file operation to
finish&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;During operation the &lt;em&gt;dev_read&lt;/em&gt;/&lt;em&gt;dev_write&lt;/em&gt; function does the first register
write to the I2C controller and then puts itself on a wait queue. The state
machine in the ISR will do the remaining register writes to the controller one
at a time. When the last operation has finished the ISR wakes up the sleeping
process.&lt;/p&gt;

&lt;p&gt;The wait queue handling deserves some further explanation as to why we cannot
use the more convenient &lt;em&gt;wait_event_interruptible&lt;/em&gt; and instead have to expanded
the sequence as follows.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prepare_to_wait(&amp;amp;wq, &amp;amp;wait, TASK_INTERRUPTIBLE);
/* I2C address device for write mode */
state = S_WRITE_1;
axi_master_write(i2c_ctrl_addr, i2c_ctrl_we_bit | i2c_ctrl_start_bit | I2C_ADDR &amp;lt;&amp;lt; 1 | 0 &amp;lt;&amp;lt; 0);
schedule();
finish_wait(&amp;amp;wq, &amp;amp;wait);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The reason for this is that we need to write the controller command (that will
eventually generate the interrupt so that our ISR wakes us up) before we go to
sleep. However if we for some reason got delayed at the point after the
controller write but before entering our sleep we could have a situation where
the ISR signals us to wake up before we have gone to sleep and then, when we
actually do go to sleep, there will be no ISR to wake us up.&lt;/p&gt;

&lt;p&gt;To deal with this situation it is a common pattern to mark ourselves as
sleeping with the &lt;em&gt;prepare_to_wait&lt;/em&gt; call, then do the controller write and
finally yield with a call to &lt;em&gt;schedule&lt;/em&gt;. This way there is no harm if the ISR
wakes us up before yielding.&lt;/p&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h2&gt;
&lt;p&gt;Now there are certainly more improvements that could be made to the driver and
especially in the area of concurrent access to the device but I think that we
are going to be happy with the current state for this post. To be honest the
driver for this device feels a bit contrived and I would rather revisit this
topic with a more realistic device (e.g. some sort of communications device
with ring buffers for rx and tx).&lt;/p&gt;

&lt;p&gt;Did you like this post? Questions or feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">Now we are going to revisit the device driver from part 3 of this series and redo it properly.</summary></entry><entry><title type="html">A basic I2C controller - part 3</title><link href="https://www.zzzconsulting.se/2018/07/19/i2c-controller-part-3.html" rel="alternate" type="text/html" title="A basic I2C controller - part 3" /><published>2018-07-19T00:00:00+02:00</published><updated>2018-07-19T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/07/19/i2c-controller-part-3</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/07/19/i2c-controller-part-3.html">&lt;p&gt;In today’s post we will start writing a Linux device driver for our simulated
I2C EPROM. It will be a simple character device that shows up as &lt;em&gt;/dev/zzz-i2c-eprom&lt;/em&gt;
and allows data to be read and written as in&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo &quot;Hello EPROM!&quot; &amp;gt; /dev/zzz-i2c-eprom
cat /dev/zzz-i2c-eprom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;interrupts&quot;&gt;Interrupts&lt;/h2&gt;
&lt;p&gt;Since I2C is slow and we do not want to busy-wait on the status register inside
the driver (we actually could if we kept calling &lt;em&gt;schedule()&lt;/em&gt; but lets try to
do it properly) we need to generate a interrupt from the block once the busy
status de-asserts.&lt;/p&gt;

&lt;p&gt;Generating asynchronous signals from the block poses a problem for our current
socket based simulation system as it is totally synchronous and everything is
initiated from the QEMU side.&lt;/p&gt;

&lt;p&gt;To deal with the asynchronous nature of interrupts we are going to introduce a
second socket on which the VPI code can post interrupt requests. In our QEMU
device we will create a thread that blocks on a receive on this socket and once
a IRQ arrives it will acquire the &lt;em&gt;Big QEMU Lock&lt;/em&gt; and pass the IRQ on to the
QEMU internals.&lt;/p&gt;

&lt;h2 id=&quot;problems&quot;&gt;Problems&lt;/h2&gt;
&lt;p&gt;Unfortunately it turns out that getting an interrupt mapped through Linux in
modern days is a bit more difficult than I expected. Seemingly to get this
machinery to play along nicely with us we will have to do it the real proper
way using the &lt;em&gt;platform device&lt;/em&gt; framework and adding &lt;em&gt;device tree (DTS)&lt;/em&gt;
entries. Doing so will quite frankly require a bit of read up from my side so
we will postpone that to the next post in this series. For now let’s just do it
the busy-wait way and verify that everything works.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;
&lt;p&gt;Now that we got that out of the way let’s get started with our device driver.
We are going to implement it as an out-of-tree kernel module as it simplifies
building.&lt;/p&gt;

&lt;p&gt;The code for the non-interrupt driven device driver can be found in
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/linux/i2c-eprom-driver.c&quot;&gt;linux/i2c-eprom-driver.c&lt;/a&gt;.
Notice that we are reusing a lot of code from
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/axi_master_client.c&quot;&gt;axi_master_client.c&lt;/a&gt;
from the first post.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT/i2c-controller/linux
make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm -C $ZZZ_ROOT/linux M=${PWD} modules
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;After building the driver be sure to remember to copy the resulting
&lt;em&gt;i2c-eprom-driver.ko&lt;/em&gt; to the BusyBox file system and rebuild the image&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp $ZZZ_ROOT/i2c-controller/linux/i2c-eprom-driver.ko $ZZZ_ROOT/busybox/_install/
pushd $ZZZ_ROOT/busybox/_install
find . -print0 | cpio --null -ov --format=newc | gzip -9 &amp;gt; $ZZZ_ROOT/initramfs.cpio.gz
popd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;
&lt;p&gt;Once built and moved to the BusyBox filesystem the module installs as follows
into our running Linux system&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;insmod i2c-eprom-driver.ko
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Since we already setup the BusyBox hotplug daemon &lt;em&gt;mdev&lt;/em&gt; in the previous post
the device file &lt;em&gt;/dev/zzz-i2c-eprom&lt;/em&gt; should automatically appear in the file
system once the module is installed.&lt;/p&gt;

&lt;p&gt;Now we can finally try out the full system! Let’s start by clearing the memory
with zeros, then write some string into it and verify that it reads back.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dd if=/dev/zero of=/dev/zzz-i2c-eprom count=16 bs=1
echo &quot;Hello world!!!&quot; &amp;gt; /dev/zzz-i2c-eprom
cat /dev/zzz-i2c-eprom
echo -n &quot;J&quot; &amp;gt; /dev/zzz-i2c-eprom
cat /dev/zzz-i2c-eprom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h2&gt;
&lt;p&gt;And there we have it, a complete simulation chain from custom RTL to a Linux
device driver. In my opinion this is pretty cool and the best thing of all is
that it does not use any pesky proprietary software or vendor branches.&lt;/p&gt;

&lt;p&gt;In the next post we will be looking at the interrupt mapping and improving the
device driver.&lt;/p&gt;

&lt;p&gt;Did you like this post? Questions or feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">In today’s post we will start writing a Linux device driver for our simulated I2C EPROM. It will be a simple character device that shows up as /dev/zzz-i2c-eprom and allows data to be read and written as in</summary></entry><entry><title type="html">A basic I2C controller - part 2</title><link href="https://www.zzzconsulting.se/2018/07/18/i2c-controller-part-2.html" rel="alternate" type="text/html" title="A basic I2C controller - part 2" /><published>2018-07-18T00:00:00+02:00</published><updated>2018-07-18T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/07/18/i2c-controller-part-2</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/07/18/i2c-controller-part-2.html">&lt;p&gt;In this post we will integrate our I2C controller simulation with QEMU. If
you didn’t already know &lt;a href=&quot;https://en.wikipedia.org/wiki/QEMU&quot;&gt;QEMU&lt;/a&gt; is a free and
open-source emulator that performs hardware virtualization. More specifically
it will allow us to emulate an ARM system where we can connect our I2C
controller as a memory mapped device. We are going to pick the ARM
VersatileExpress development board, that is already emulated by QEMU, and
modify it by adding our device.&lt;/p&gt;

&lt;h2 id=&quot;get-modify-and-build-qemu&quot;&gt;Get, modify and build QEMU&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT
wget https://download.qemu.org/qemu-2.12.0.tar.xz
tar xf qemu-2.12.0.tar.xz
mkdir qemu-build
cd $ZZZ_ROOT/qemu-build
../qemu-2.12.0/configure --prefix=$ZZZ_ROOT/qemu-install
make install -j8
export PATH=$ZZZ_ROOT/qemu-install/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To register our device we need to add the following line to the
&lt;em&gt;a9_daughterboard_init&lt;/em&gt; function of &lt;em&gt;qemu-2.12.0/hw/arm/vexpress.c&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sysbus_create_simple(&quot;axi_master_client_device&quot;, 0x1e00b000, NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;For the actual implementation of our device
(&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/qemu/axi_master_client_device.c&quot;&gt;qemu/axi_master_client_device.c&lt;/a&gt;)
I simply sym-linked to it, and remembered to update the &lt;em&gt;hw/arm/Makefile.objs&lt;/em&gt;
so that it gets built. As can be seen adding a memory mapped device to an ARM
based QEMU system turned out to be rather straight forward and all we really
needed to do was to implement one hook for memory reads and one hook for memory
writes to our region.&lt;/p&gt;

&lt;h2 id=&quot;prepare-the-linux-system&quot;&gt;Prepare the Linux system&lt;/h2&gt;
&lt;p&gt;Second we are going to go ahead and build a complete little Linux system
(kernel and busybox file system). While it is strictly not needed for what we
are trying to achieve in this post it will be convenient to have for testing as
you will see shortly.&lt;/p&gt;

&lt;p&gt;Before we do anything we need to make sure that we have a usable cross compiler
for our intended target. I grabbed a pre-built one from
&lt;a href=&quot;https://releases.linaro.org/components/toolchain/binaries/latest-6/arm-linux-gnueabihf/&quot;&gt;here&lt;/a&gt;.
Then we need to acquire and build the kernel sources&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT
wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.17.8.tar.xz
tar xf linux-4.17.8.tar.xz
ln -s linux-4.17.8 linux
cd $ZZZ_ROOT/linux
make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm vexpress_defconfig
make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm -j8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;After that BusyBox&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT
wget http://busybox.net/downloads/busybox-1.29.1.tar.bz2
tar xf busybox-1.29.1.tar.bz2
ln -s busybox-1.29.1 busybox
cd $ZZZ_ROOT/busybox
make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm defconfig
make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm menuconfig (enable static link option)
make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm -j8 install
cd _install
mkdir proc sys dev etc etc/init.d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;put the following lines in etc/init.d/rcS&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
mount &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; proc none /proc
mount &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; sysfs none /sys
mount &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; debugfs none /sys/kernel/debug/
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; /sbin/mdev &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /proc/sys/kernel/hotplug
/sbin/mdev &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and make it executable&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chmod +x etc/init.d/rcS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;now finally create the file system image&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pushd $ZZZ_ROOT/busybox/_install
find . -print0 | cpio --null -ov --format=newc | gzip -9 &amp;gt; $ZZZ_ROOT/initramfs.cpio.gz
popd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;

&lt;h3 id=&quot;linux-boot&quot;&gt;Linux boot&lt;/h3&gt;
&lt;p&gt;First let us boot up the Linux system&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qemu-system-arm -M vexpress-a9 -kernel $ZZZ_ROOT/linux/arch/arm/boot/zImage -dtb $ZZZ_ROOT/linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -initrd $ZZZ_ROOT/initramfs.cpio.gz -append &quot;console=ttyAMA0 ignore_loglevel log_buf_len=10M print_fatal_signals=1 LOGLEVEL=8 earlyprintk=vga,keep sched_debug root=/dev/ram rdinit=/sbin/init&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;QEMU has a monitor that can be entered by issuing &lt;strong&gt;ctrl-a c&lt;/strong&gt;. There is also a
shorthand for the very useful quit command by pressing &lt;strong&gt;ctrl-a x&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;At this point just verify that the Linux system boots up and that you can enter
the BusyBox shell.&lt;/p&gt;

&lt;h3 id=&quot;the-qemu-and-axi-part&quot;&gt;The QEMU and AXI part&lt;/h3&gt;
&lt;p&gt;BusyBox has a very convenient utility command called &lt;em&gt;devmem&lt;/em&gt; that allows us to
access physical memory addresses without the hassle of having to write a kernel
module at this point, or having to write a custom user space program to fiddle
with &lt;em&gt;/dev/mem&lt;/em&gt; for that matter (since that is exactly what &lt;em&gt;devmem&lt;/em&gt; does).&lt;/p&gt;

&lt;p&gt;The AXI slave of our I2C controller implements a few dummy registers (they can
be written and read but serve no other purpose) that we can use to verify our
system. The three registers are mapped at 0x1e00b000, 0x1e00b004 and
0x1e00b008.&lt;/p&gt;

&lt;p&gt;First start the RTL simulation with AXI master server&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vvp -M. -mvpi_axi_master i2c.vvp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Then start the QEMU system (as described above) and use &lt;em&gt;devmem&lt;/em&gt; to fire away a
few writes and verify that the values read back are as expected.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;devmem 0x1e00b000 w 0x11112222
devmem 0x1e00b004 w 0x33334444
devmem 0x1e00b008 w 0x55556666

devmem 0x1e00b004
devmem 0x1e00b000
devmem 0x1e00b008
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Note that we already verified that the I2C controller was working reasonably
well in the previous post so we can delay further testing of that until the
next post where we implement a proper device driver.&lt;/p&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h2&gt;
&lt;p&gt;That concludes today’s post. As always the interesting details are in the code
so be sure to check it out.&lt;/p&gt;

&lt;p&gt;Did you like this post? Questions or feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">In this post we will integrate our I2C controller simulation with QEMU. If you didn’t already know QEMU is a free and open-source emulator that performs hardware virtualization. More specifically it will allow us to emulate an ARM system where we can connect our I2C controller as a memory mapped device. We are going to pick the ARM VersatileExpress development board, that is already emulated by QEMU, and modify it by adding our device.</summary></entry><entry><title type="html">A basic I2C controller - part 1</title><link href="https://www.zzzconsulting.se/2018/07/17/i2c-controller-part-1.html" rel="alternate" type="text/html" title="A basic I2C controller - part 1" /><published>2018-07-17T00:00:00+02:00</published><updated>2018-07-17T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/07/17/i2c-controller-part-1</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/07/17/i2c-controller-part-1.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;I2C is this two wire bus protocol that is very common in the embedded sphere
and the reader is most likely already familiar with it so the introduction here
will be brief.  As the name suggests it is a protocol for communicating between
ICs and the specification for the protocol can be found
&lt;a href=&quot;http://cache.nxp.com/documents/user_manual/UM10204.pdf&quot;&gt;here&lt;/a&gt;.  The two wires
consist of a clock (SCL) and a data (SDA), the master is responsible for
initiating all transactions. Since it is a bit more complicated than just a
shift-register there are special rules for when &lt;em&gt;SDA&lt;/em&gt; transitions may occur
with respect to &lt;em&gt;SCL&lt;/em&gt; (i.e. not just data sampled at rising edge of clk
end-of-story). For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A SDA 1 -&amp;gt; 0 transition when SCL is high signals a START condition&lt;/li&gt;
  &lt;li&gt;A SDA 0 -&amp;gt; 1 transition when SCL is high signals a STOP condition&lt;/li&gt;
  &lt;li&gt;SDA transitions when SCL is low are used for normal data signaling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course there are more details to it but you can read all about those in the
spec above.&lt;/p&gt;

&lt;p&gt;In this post we are going to outline the RTL (Verilog) implementation and
simulation of a basic I2C controller that connects to a host as an AXI slave. In
future posts we will connect the simulation with QEMU and finish it all up by
writing a Linux device driver.&lt;/p&gt;

&lt;h2 id=&quot;preparations&quot;&gt;Preparations&lt;/h2&gt;
&lt;p&gt;To follow along the reader is urged to acquire the following packages (Verilog
simulator and waveform viewer)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install iverilog gtkwave
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;As always with these things a lot of commands will be issued and a lot of paths
will be used so in an attempt to keep the commands copy-pastable (without the
reader having to manually modify the paths all the time) we are going to
introduce the following environment variable and use that as much as possible
through out the posts&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ZZZ_ROOT=some/path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now let us begin by checking out the Git repository
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller&quot;&gt;https://github.com/markus-zzz/i2c-controller&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT
git clone https://github.com/markus-zzz/i2c-controller
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;It should be noted that a single repository and single branch is used for the
entire post series so some of the files may contain code that will first be
relevant for the later posts.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;
&lt;p&gt;After some thinking I decided that the AXI interface of my simple I2C
controller should expose these two registers&lt;/p&gt;

&lt;h4 id=&quot;control-register&quot;&gt;Control register&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Field&lt;/th&gt;
      &lt;th&gt;Bits&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;we&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Write enable i.e. should we be driving the SDA during the transaction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;start&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Generate start condition before&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;stop&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Generate stop condition after&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;byte&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Data byte to write (could be address in which case the 8:th bit indicates read or write during following transaction)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;status-and-read-register&quot;&gt;Status (and read) register&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Field&lt;/th&gt;
      &lt;th&gt;Bits&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;busy&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Controller busy with ongoing transaction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ack&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Acknowledge status for last transaction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;byte&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Data byte read if last transaction was read (we always sample data even if we are driving SDA ourselves)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If one thinks a bit more about the signaling one realises that dividing the SCL
into four phases might be a good idea so we use a clock enable scheme as
follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// I2C clocking scheme
//
//        -+                             +-----------------------------+
// SCL     |                             |                             |
//         +-----------------------------+                             +-
//
//        -+            +-+            +-+            +-+            +-+
// 4x_en   |            | |            | |            | |            | |
//         +------------+ +------------+ +------------+ +------------+ +-
//
// phase      2'b00          2'b01          2'b10          2'b11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In other words we use the same clock domain as the AXI bus and ‘divide’ the clock
locally by producing a clock enable signal with four pulses per &lt;em&gt;SCL&lt;/em&gt; period. For
each pulse we increment the two bit phase counter that is used by the remainder
of the design.&lt;/p&gt;

&lt;p&gt;The implementation of the controller is in
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/i2c_controller.v&quot;&gt;i2c_controller.v&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Next thing we need to wrap an AXI slave interface around the controller and
that can be seen in
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/i2c_axi_slave.v&quot;&gt;i2c_axi_slave.v&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;simulation&quot;&gt;Simulation&lt;/h2&gt;
&lt;p&gt;For testing I found
&lt;a href=&quot;https://github.com/olofk/i2c/blob/master/bench/verilog/i2c_slave_model.v&quot;&gt;this&lt;/a&gt;
slave model of a I2C EPROM.&lt;/p&gt;

&lt;p&gt;Now if you think about the amount of AXI signaling that would be required to
write and read something from the EPROM model you quickly realise that it would
be a pain to write all that in plain Verilog. In fact it would be much easier
if we could write all this in a programming language like C and luckily thanks
to VPI (Verilog Procedural Interface) this is a straight forward task.&lt;/p&gt;

&lt;p&gt;Using VPI we connect a callback on value change events for the AXI clock signal
and from there we can manipulate the remainder of the bus signals. We have a
simple software driven state machine that, in its idle state, receives commands
from a socket and, whether it was a read or a write, drives the bus signals
accordingly.&lt;/p&gt;

&lt;p&gt;Now performing AXI reads and writes in our simulation is a simple matter of
sending the appropriate command packet over the socket and by so we have
achieved a reasonable separation between our simulation environment and the bus
interface to it.&lt;/p&gt;

&lt;p&gt;The attentive reader might realise that the approach of having the RTL
simulator block on a socket inside the value change callback for the AXI clock
will effectively block the simulation unless it is constantly being fed with
command packets over the socket. As a lucky coincidence this stream of socket
commands is exactly what happens in the test suite used in this post as it
constantly busy-waits on the status register after each write to the control
register.&lt;/p&gt;

&lt;p&gt;Later on though when we use QEMU and a proper interrupt driven device driver
this will present a problem so we might as well try to solve it now. On the
opposite side of blocking we could do the receive in non-blocking mode and
effectively have the RTL simulation running at full speed all the time. While
this would be functionally correct it is somewhat undesirable since it would be
a huge wast of simulation cycles (and possibly producing some huge dump.vcd
files).&lt;/p&gt;

&lt;p&gt;A better approach is to do a bit of both with the concept of a clock request
signal from the block (we can use the busy bit of the status register for this
purpose). While the block is busy it needs a clock to finish (and become ready)
and in this state we use a non-blocking receive. On the other hand when the
block is ready it is safe to fall back on blocking receives as there is no work
to do until we get a command from the AXI.&lt;/p&gt;

&lt;p&gt;To try it all out simply do&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT/i2c-controller
./build-all.sh
./run-all.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If all went well this should have executed the test code in
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/axi_master_client.c&quot;&gt;axi_master_client.c&lt;/a&gt;
writing patterns to the I2C connected memory and then reading back and
verifying.&lt;/p&gt;

&lt;p&gt;To really see what is going on this might be a good opertunity to bring up the
waveform viewer and inspect the signals in &lt;em&gt;tb.dut&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gtkwave dump.vcd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In the next post we try to integrate our socket based model with QEMU and later
on in a third post we will attempt to write a Linux device driver for the
EPROM.&lt;/p&gt;

&lt;p&gt;Did you like this post? Questions or feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction I2C is this two wire bus protocol that is very common in the embedded sphere and the reader is most likely already familiar with it so the introduction here will be brief. As the name suggests it is a protocol for communicating between ICs and the specification for the protocol can be found here. The two wires consist of a clock (SCL) and a data (SDA), the master is responsible for initiating all transactions. Since it is a bit more complicated than just a shift-register there are special rules for when SDA transitions may occur with respect to SCL (i.e. not just data sampled at rising edge of clk end-of-story). For example:</summary></entry><entry><title type="html">An LLVM exercise</title><link href="https://www.zzzconsulting.se/2018/07/16/llvm-exercise.html" rel="alternate" type="text/html" title="An LLVM exercise" /><published>2018-07-16T00:00:00+02:00</published><updated>2018-07-16T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/07/16/llvm-exercise</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/07/16/llvm-exercise.html">&lt;p&gt;Let’s write an LLVM optimization pass to familiarize ourselves with the
environment. Of course LLVM already does everything even remotely interesting
so in order to have some non-trivial example we are going to replace an
existing pass. The pass of choice is going to be &lt;em&gt;mem2reg&lt;/em&gt; mainly because it is
quite central and I happen to have experience implementing this very pass in a
different compiler framework.&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;
&lt;p&gt;One interesting thing about LLVM is its approach to entering SSA-form (i.e.
satisfying the static single assignment condition by placement of phi-nodes).
Traditionally this is considered a front end responsibility to place phi-nodes
but LLVM takes a different approach. Namely have the front end generate an
alloca for each variable then loads for the uses and stores for the defs.  Note
that technically speaking this code is already in SSA form (it is just that it
is terribly inefficient). Later on the pass &lt;em&gt;mem2reg&lt;/em&gt; comes along and optimizes
this effectively removing the inefficient memory accesses for these variables.&lt;/p&gt;

&lt;p&gt;This is nice because it makes the front end simpler, it can focus on its AST to
IR translation without additional complexities. On the downside you could argue
that it makes the compilation process inefficient because you have the front
end generate a bunch of IR that will almost immediately be optimized away in
the middle end. In my opinion though that is the name of the game in compiler
engineering, to not worrying about everything at once but instead have each
part do one thing well and have an efficient IR infrastructure that allows for
cheap IR updates.&lt;/p&gt;

&lt;h2 id=&quot;prerequisites&quot;&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;To follow along you will need to have an LLVM development environment setup.
This is all pretty well described
&lt;a href=&quot;https://llvm.org/docs/GettingStarted.html&quot;&gt;here&lt;/a&gt; but in short this is what I
did&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ROOT=&amp;lt;some path&amp;gt;
export PATH=$ROOT/install/bin:$PATH
mkdir -p $ROOT
mkdir -p $ROOT/build
mkdir -p $ROOT/install
cd $ROOT
wget http://releases.llvm.org/6.0.1/llvm-6.0.1.src.tar.xz
wget http://releases.llvm.org/6.0.1/cfe-6.0.1.src.tar.xz
tar xf llvm-6.0.1.src.tar.xz
cd $ROOT/llvm-6.0.1.src/tools/
tar xf $ROOT/cfe-6.0.1.src.tar.xz
cd $ROOT/build
cmake -G Ninja $ROOT/llvm-6.0.1.src/ -DCMAKE_INSTALL_PREFIX=$ROOT/install -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON -DLLVM_TARGETS_TO_BUILD=&quot;ARM&quot;
ninja install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;experiment&quot;&gt;Experiment&lt;/h2&gt;
&lt;p&gt;Let us start by looking at the LLVM IR before and after &lt;em&gt;mem2reg&lt;/em&gt; for the following example&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Invoking the front end and emitting IR without applying any optimizations is as simple as&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang -target armv7h -mfloat-abi=hard sum.c -O0 -S -emit-llvm -o sum.ll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define arm_aapcs_vfpcc i32 @sum(i32* %data, i32 %len) #0 {
entry:
  %data.addr = alloca i32*, align 4
  %len.addr = alloca i32, align 4
  %s = alloca i32, align 4
  %i = alloca i32, align 4
  store i32* %data, i32** %data.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  store i32 0, i32* %s, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %len.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32*, i32** %data.addr, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %2, i32 %3
  %4 = load i32, i32* %arrayidx, align 4
  %5 = load i32, i32* %s, align 4
  %add = add nsw i32 %5, %4
  store i32 %add, i32* %s, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, i32* %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %7 = load i32, i32* %s, align 4
  ret i32 %7
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Then running the standard &lt;em&gt;mem2reg&lt;/em&gt; pass on this IR&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;opt -passes mem2reg -S sum.ll -o sum-mem2reg.ll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define arm_aapcs_vfpcc i32 @sum(i32* %data, i32 %len) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %s.0 = phi i32 [ 0, %entry ], [ %add, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, %len
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %data, i32 %i.0
  %0 = load i32, i32* %arrayidx, align 4
  %add = add nsw i32 %s.0, %0
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret i32 %s.0
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;As can be seen the effects of the &lt;em&gt;mem2reg&lt;/em&gt; pass are rather dramatic. Gone are the
inefficient variable &lt;em&gt;loads&lt;/em&gt;, &lt;em&gt;stores&lt;/em&gt; and &lt;em&gt;alloca&lt;/em&gt; instructions.&lt;/p&gt;

&lt;h2 id=&quot;implement-our-own&quot;&gt;Implement our own&lt;/h2&gt;
&lt;p&gt;Now let’s implement our own &lt;em&gt;mem2reg&lt;/em&gt; pass (and call it &lt;em&gt;ourmem2reg&lt;/em&gt;) and see if we
can achieve similar results. The algoritm we will use will be the classical one
by Cytron et al. and the interested reader can find all the details in [1].&lt;/p&gt;

&lt;p&gt;The basics of writing an LLVM pass are described
&lt;a href=&quot;http://llvm.org/docs/WritingAnLLVMPass.html&quot;&gt;here&lt;/a&gt;. Pay special attention to
the section about setting up the build environment to build the pass as a
loadable module. Doing so will save a lot of pain.&lt;/p&gt;

&lt;p&gt;I went ahead and wrote &lt;a href=&quot;https://www.zzzconsulting.se/download/OurMem2Reg.cpp&quot;&gt;OurMem2Reg.cpp&lt;/a&gt;
and will now try to describe its contents in some detail.&lt;/p&gt;

&lt;h3 id=&quot;linkdefsandusestovar&quot;&gt;linkDefsAndUsesToVar&lt;/h3&gt;
&lt;p&gt;Given a variable (i.e. an alloca) we need to find the definitions and uses of
this variable. This corresponds to finding the store and load instructions that
use the alloca as an address. We also need to make sure that these are the only
uses of the alloca i.e. the address does not escape and allow for potential
modifictaion else where.&lt;/p&gt;

&lt;h3 id=&quot;renamerecursive&quot;&gt;renameRecursive&lt;/h3&gt;
&lt;p&gt;Here we walk the dominator tree and perform a pre-order action and a post-order action.&lt;/p&gt;
&lt;h4 id=&quot;pre-order-action&quot;&gt;Pre-order action&lt;/h4&gt;
&lt;p&gt;Scan for def and use instructions in the block and maintain a definition stack
for each variable. A use (i.e. a load instruction) get replaced by the value on
top of the definition stack and a def (store instruction) pushes the value
stored onto the stack.&lt;/p&gt;
&lt;h4 id=&quot;post-order-action&quot;&gt;Post-order action&lt;/h4&gt;
&lt;p&gt;For the post-order action we need to pop the definitions put on the stack once
we are done at a level in the dominator tree and about to move up. Obviously
once we are done with a block and all the blocks that are dominated by it we
need to remove the variable definitions that came from that block since they
are no longer valid.&lt;/p&gt;

&lt;h3 id=&quot;runonfunction&quot;&gt;runOnFunction&lt;/h3&gt;
&lt;p&gt;The driver of the pass&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Look for &lt;em&gt;alloca&lt;/em&gt; instructions (and according to LLVM conventions they are
all located in the entry block of the function) and call
&lt;em&gt;linkDefsAndUsesToVar&lt;/em&gt; on them to gather information.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In the previous step we took note of in which blocks there were definitions
of the variable. Now we need to insert phi-nodes in the dominance frontier
of these blocks (and keeping in mind that when we insert a phi-node that acts
as a new definition so we need to insert a phi-node in the dominance frontier
of that block as well). In other words we need to insert phi-nodes in the
iterated dominance frontier of the original definition blocks.  Luckily LLVM
has a new fancy framework for computing the iterated dominance frontier set
from a set of definition blocks so we simply use that (if we were to compute it
ourselves I would recommend the method described in [2]).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now we enter the actual work horse of the algorithm - the renaming phase.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The only thing that is left to do now is to remove the trash left behind,
i.e. removing now useless load, store and alloca instructions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;getanalysisusage&quot;&gt;getAnalysisUsage&lt;/h3&gt;
&lt;p&gt;Simply informing the pass manager that we need a valid dominator tree and that
we are not going to make changes to the CFG.&lt;/p&gt;

&lt;h2 id=&quot;evaluate&quot;&gt;Evaluate&lt;/h2&gt;
&lt;p&gt;Running the optimizer with our pass loaded as a module&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;opt -load $ROOT/build/lib/LLVMOurMem2Reg.so -ourmem2reg -S sum.ll -o sum-ourmem2reg.ll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;giving us the following result which looks rather identical to what we get with
the stock &lt;em&gt;mem2reg&lt;/em&gt; pass&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define arm_aapcs_vfpcc i32 @sum(i32* %data, i32 %len) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %1 = phi i32 [ 0, %entry ], [ %add, %for.inc ]
  %cmp = icmp slt i32 %0, %len
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %data, i32 %0
  %2 = load i32, i32* %arrayidx, align 4
  %add = add nsw i32 %1, %2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret i32 %1
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h2&gt;
&lt;p&gt;So what areas of the LLVM infrastructure have we familiarized ourselves with in
this exercise?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Traversing the CFG&lt;/li&gt;
  &lt;li&gt;Traversing the SSA graph (looking for uses of an instruction)&lt;/li&gt;
  &lt;li&gt;Requesting a dominator tree and traversing it&lt;/li&gt;
  &lt;li&gt;Using the iterated dominance frontier machinery&lt;/li&gt;
  &lt;li&gt;Replacing instructions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally I make no claim that the pass implemented is 100% correct and there are
surely corner cases that would need to be handled for a proper implementation.
That however was not the purpose of this post but rather to provide an exercise
to familiarize oneself with the LLVM API using a somewhat real example doing
something useful.&lt;/p&gt;

&lt;p&gt;In fact there is one issue if a variable is used before it is defined (e.g. not
initializing the summation variable in the example above) will result in a
compiler crash. Of course using a variable before it is defined is hardly good
practice but the pass should still handle it correctly. Fixing this is left as
an exercise for the reader but it is simply a matter of inserting a undef
instruction if we encounter a use while the definition stack is empty.&lt;/p&gt;

&lt;p&gt;Did you like this post? Questions or feedback - leave a comment below!&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;p&gt;[1] Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth
Zadeck. 1991. Efficiently computing static single assignment form and the
control dependence graph. ACM Trans. Program. Lang. Syst. 13, 4 (October 1991),
451-490. DOI=http://dx.doi.org/10.1145/115372.115320&lt;/p&gt;

&lt;p&gt;[2] Cooper, Keith &amp;amp; Harvey, Timothy &amp;amp; Kennedy, Ken. (2006). A Simple, Fast
Dominance Algorithm. Rice University, CS Technical Report 06-33870.&lt;/p&gt;</content><author><name></name></author><summary type="html">Let’s write an LLVM optimization pass to familiarize ourselves with the environment. Of course LLVM already does everything even remotely interesting so in order to have some non-trivial example we are going to replace an existing pass. The pass of choice is going to be mem2reg mainly because it is quite central and I happen to have experience implementing this very pass in a different compiler framework.</summary></entry></feed>