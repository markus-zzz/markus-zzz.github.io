<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="https://www.zzzconsulting.se/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.zzzconsulting.se/" rel="alternate" type="text/html" /><updated>2020-08-22T11:57:43+02:00</updated><id>https://www.zzzconsulting.se/feed.xml</id><title type="html">ZZZ-Consulting</title><subtitle>Consulting services offered in the fields of Compiler engineering, Graphics programming and Embedded computing.</subtitle><entry><title type="html">Commodore 64 experiments part-2 (SID)</title><link href="https://www.zzzconsulting.se/2020/08/22/c64-part-2.html" rel="alternate" type="text/html" title="Commodore 64 experiments part-2 (SID)" /><published>2020-08-22T00:00:00+02:00</published><updated>2020-08-22T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2020/08/22/c64-part-2</id><content type="html" xml:base="https://www.zzzconsulting.se/2020/08/22/c64-part-2.html">&lt;p&gt;&lt;strong&gt;NOTE: I wrote the majority of this post (and the implementation) about a month
ago but never got around to publish it until now.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;After the last post’s progress of getting the system to boot and being able to
run small test programs I felt motivated to carry on. While perhaps it would
have been wiser focus on the core system I instead turned my attention to the
SID chip.&lt;/p&gt;

&lt;p&gt;Again, since I did not really do much with my C64 back in the day, and have had
no reason to study it afterwards, my pre-existing knowledge about the SID was
pretty limited. I basically only knew “it was the chip that made the sounds”.&lt;/p&gt;

&lt;p&gt;To get an idea what the SID sounds like the most convenient solution is proably
to head over to the online player at &lt;a href=&quot;https://deepsid.chordian.net/&quot;&gt;DeepSID&lt;/a&gt;
where there is a huge collection of C64 music from games and demos that will
play right in your browser.&lt;/p&gt;

&lt;p&gt;So the SID player plays SID files, but what exactly is a &lt;code class=&quot;highlighter-rouge&quot;&gt;.sid&lt;/code&gt; file? Well
unlike modern audio formats it does not contain PCM samples (e.g. WAV or
compressed formats like MP3) nor does it contain the tones/or notes like a MIDI
file does. Instead it actually contains 6502 machine code that writes values
into SID registers to produce the desired sound. As such a SID player is
essentially a scaled down C64 emulator. For a complete description of the SID
file format see &lt;a href=&quot;https://www.hvsc.c64.org/download/C64Music/DOCUMENTS/SID_file_format.txt&quot;&gt;this
link&lt;/a&gt;
but for our purposes it suffices to say that it contain two entry points. One
entry point for an initialization routine that will prepare to play a given
song (SID files contain many) and a second entry point for the play routine
that is to be called repeatedly (usually at 60Hz).&lt;/p&gt;

&lt;p&gt;Now while this format plays directly in a SID player it requires some
scaffolding and relocation to play on actual C64 hardware. This is where
&lt;a href=&quot;http://psid64.sourceforge.net/&quot;&gt;PSID64&lt;/a&gt; utility comes in, it will provide this
scaffolding and relocation and basically converts a &lt;code class=&quot;highlighter-rouge&quot;&gt;.sid&lt;/code&gt; file to a &lt;code class=&quot;highlighter-rouge&quot;&gt;.prg&lt;/code&gt;
that can be loaded and run on a C64.&lt;/p&gt;

&lt;p&gt;A huge collection of SID files can be found at the &lt;a href=&quot;https://www.hvsc.c64.org/&quot;&gt;High Voltage SID Collection
(HVSC)&lt;/a&gt; and convinently their downloads page also
provide &lt;a href=&quot;https://boswme.home.xs4all.nl/HVSC/HVSC73_PSID64_packed.7z&quot;&gt;an archive of the HVSC collection converted to PSID64
format&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Getting the PSID64 &lt;code class=&quot;highlighter-rouge&quot;&gt;.prg&lt;/code&gt; to run on MyC64 required some work but it mostly
boiled down to finally implementing bank switching.&lt;/p&gt;

&lt;p&gt;Let’s try and fire up the good old Bubble Bobble tune&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./myc64-sim --cmd-load-prg=130:./MUSICIANS/C/Clarke_Peter/Bubble_Bobble.prg --cmd-inject-keys=135:&quot;LIST&amp;lt;RETURN&amp;gt;RUN&amp;lt;RETURN&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/download/c64/psid64-bubble-bobble.apng&quot; alt=&quot;PSID64 playing Bubble Bobble&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So now that we have something to test the SID with we can move our focus to try
and emulate the actual chip.&lt;/p&gt;

&lt;p&gt;For those like me who don’t know anything about music synthesis the following
videos (&amp;lt; 10min in total) proved helpful to intorduce the basic concepts&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/qV10Gb-Dvao&quot;&gt;What’s Synthesis and Sound Design? Part 1: Oscillators &amp;amp; Waveforms (Music Theory)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/In23B9qZhI8&quot;&gt;What’s Synthesis and Sound Design? Part 2: Subtractive Synthesis &amp;amp; Filters (Music Theory)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/n-k0NQ5lcSA&quot;&gt;What’s Synthesis and Sound Design? Part 3: Envelopes &amp;amp; ADSR (Music Theory)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After that I suggest the following souces for details about the SID&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.6502.org/documents/datasheets/mos/mos_6582_sid.pdf&quot;&gt;6582 SOUND Interface Device (SID) - datasheet&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://sid.kubarth.com/articles/interview_bob_yannes.html&quot;&gt;Interview with Bob Yannes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A very basic implementation based on that was started in
&lt;a href=&quot;https://github.com/markus-zzz/myc64/blob/master/rtl/sid.v&quot;&gt;rtl/sid.v&lt;/a&gt;. As
usual it is far from complete but it is able to produce some basic tunes.
Modifying &lt;code class=&quot;highlighter-rouge&quot;&gt;myc64-sim&lt;/code&gt; to store the generated audio signal into a &lt;code class=&quot;highlighter-rouge&quot;&gt;.wav&lt;/code&gt; file
allowed us to capture &lt;a href=&quot;/download/c64/Bubble_Bobble-MyC64-sim.wav&quot;&gt;Bubble Bobble - MyC64
SID&lt;/a&gt;. This admittedly sounds quite a
bit off (especially in frequency) compared to &lt;a href=&quot;/download/c64/Bubble_Bobble-VICE-8580-ReSID.wav&quot;&gt;Bubble Bobble - VICE 8580
ReSID&lt;/a&gt; generated by the well
known &lt;a href=&quot;https://vice-emu.sourceforge.io/&quot;&gt;VICE&lt;/a&gt; emulator. Still it is good
enough as a first approximation and allows us to move on an focus on other
areas. That concludes this post. As always if you have questions or feedback -
leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">NOTE: I wrote the majority of this post (and the implementation) about a month ago but never got around to publish it until now.</summary></entry><entry><title type="html">Commodore 64 experiments part-1</title><link href="https://www.zzzconsulting.se/2020/07/12/c64-part-1.html" rel="alternate" type="text/html" title="Commodore 64 experiments part-1" /><published>2020-07-12T00:00:00+02:00</published><updated>2020-07-12T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2020/07/12/c64-part-1</id><content type="html" xml:base="https://www.zzzconsulting.se/2020/07/12/c64-part-1.html">&lt;p&gt;When I was a kid back in the 80s my parents bought our family’s first computer,
a Commodore 64 with a datasette station. I still have fond memories of that
marvelous little machine. At the time though I was only ten years old so my
mental capacity (and likely also patience) was quite limited and I never
managed to do much with it besides playing games and typing in the occasional
BASIC listing from the Sunday newspaper (that almost never worked).&lt;/p&gt;

&lt;p&gt;Now in recent times I often find myself watching retro computing episodes from
the big YouTubers in the field such as &lt;a href=&quot;https://www.youtube.com/user/adric22&quot;&gt;The 8-Bit
Guy&lt;/a&gt; and &lt;a href=&quot;https://www.youtube.com/channel/UC6gARF3ICgaLfs3o2znuqXA&quot;&gt;Retro
Recipes&lt;/a&gt;. Needless to
say they often feature the C64 and it is refreshing to be reminded of a simpler
time when things were not complicated to absurdity just for the sake of it.&lt;/p&gt;

&lt;p&gt;While I know that there are numerous C64 emulators available (mostly in
software but also a few FPGA based) I always thought that would be a neat
project to try on.&lt;/p&gt;

&lt;p&gt;Some weeks ago I ran across the &lt;a href=&quot;http://c64onfpga.blogspot.com/&quot;&gt;C64 on an
FPGA&lt;/a&gt; blog series by Johan Steenkamp, a blog
series dating from 2017 to present detailing his journey in implementing an
FPGA based C64 emulator. While I don’t agree with every design decision taken
there the work put in to implementing and the effort spent documenting it is
really impressive.&lt;/p&gt;

&lt;p&gt;So inspired by this I thought I would try doing something similar or at least
see how much work would be required to get a system that boots into BASIC.&lt;/p&gt;

&lt;h2 id=&quot;preparations&quot;&gt;Preparations&lt;/h2&gt;

&lt;p&gt;Before we can get started we need to gather some preliminary stuff.&lt;/p&gt;

&lt;h3 id=&quot;documentation&quot;&gt;Documentation&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.c64-wiki.com/wiki/Commodore_64_Programmer%27s_Reference_Guide&quot;&gt;Commodore 64 Programmer’s Reference Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://sta.c64.org/cbm64mem.html&quot;&gt;Commodore 64 memory map&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.zimmers.net/cbmpics/cbm/c64/vic-ii.txt&quot;&gt;The MOS 6567/6569 video controller (VIC-II) and its application in the Commodore 64 by Christian Bauer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.6502.org/documents/datasheets/mos/mos_6526_cia_recreated.pdf&quot;&gt;6526 Complex Interface Adapter (CIA) - datasheet&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.6502.org/documents/datasheets/mos/mos_6582_sid.pdf&quot;&gt;6582 SOUND Interface Device (SID) - datasheet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cpu&quot;&gt;CPU&lt;/h3&gt;

&lt;p&gt;A Verilog model of a 6502/6510 CPU by Arlet Ottens can be downloaded from
&lt;a href=&quot;http://ladybug.xs4all.nl/arlet/fpga/6502/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;roms&quot;&gt;ROMs&lt;/h3&gt;

&lt;p&gt;Kernal, basic and character ROMs can be picked up from
&lt;a href=&quot;http://www.zimmers.net/anonftp/pub/cbm/firmware/computers/c64/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;considerations&quot;&gt;Considerations&lt;/h2&gt;

&lt;p&gt;By today’s standards the C64 is a simply system. However when trying to
reimplement it with modern technology (and methodology) inside a single FPGA
there are a few things that need to be kept in mind.&lt;/p&gt;

&lt;p&gt;The design is based around asynchronous RAM so for reading you expect the data
to become available in the same cycle as the address is presented. This is
different from the synchronous RAM blocks found inside FPGAs where an
additional clock cycle must pass before the data is available.&lt;/p&gt;

&lt;p&gt;There are no stall cycles or handshake signals in the bus protocol so every
transaction is expected to complete immediately. Also if a chip is not
connected to the bus the writes to that will simply be ignored and reads return
a default value. When trying to bring up the system this is both good and bad.
Good because you feel you make progress fast but bad since you will probably
miss implementing functionality that turned out to be really important to avoid
those hard to find bugs later on.&lt;/p&gt;

&lt;p&gt;The CPU and VIC-II share the same bus by allowing the CPU to access during the
first phase of the clock and the VIC-II during the second phase of the clock.
This does not map really well to the single edge methodology used in most
modern designs.&lt;/p&gt;

&lt;p&gt;Also as the design is made up of discrete ICs they are connected with a classic
tri-state bus. Tri-state buses inside the fabric is not supported by modern
FPGAs so multiplexers need to be used instead. In a way though, it would be
nice to be able to closely recreate the PCB interconnect inside the FPGA and
have each IC correspond to a Verilog module with the exact same interface
signals.&lt;/p&gt;

&lt;p&gt;The VIC-II has a 8Mhz pixel clock but the remaining design is based around a
1Mhz system clock where both phases (or edges) are used. This also complicates
matters and it is always wise to avoid multiple clock domains unless absolutely
necessary.&lt;/p&gt;

&lt;h2 id=&quot;design&quot;&gt;Design&lt;/h2&gt;

&lt;p&gt;So given the considerations in the previous section I have chosen to use a
single clock domain of 8Mhz with enable signals corresponding to the positive
and negative phase of a 1Mhz clock.&lt;/p&gt;

&lt;p&gt;The single ported synchronous RAM modules are wrapped so that they act as
asynchronous RAM that can be independently accessed with the two 1Mhz phases
enable signals. See
&lt;a href=&quot;https://github.com/markus-zzz/myc64/blob/master/rtl/spram.v&quot;&gt;rtl/spram.v&lt;/a&gt; and
&lt;a href=&quot;https://github.com/markus-zzz/myc64/blob/master/rtl/sprom.v&quot;&gt;rtl/sprom.v&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A implementation of a very basic VIC-II is started in
&lt;a href=&quot;https://github.com/markus-zzz/myc64/blob/master/rtl/vic-ii.v&quot;&gt;rtl/vic-ii.v&lt;/a&gt;
and likewise for the CIA in
&lt;a href=&quot;https://github.com/markus-zzz/myc64/blob/master/rtl/cia.v&quot;&gt;rtl/cia.v&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Everything is wired up and connected to a fake keyboard matrix in
&lt;a href=&quot;https://github.com/markus-zzz/myc64/blob/master/rtl/top.v&quot;&gt;rtl/top.v&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;results-so-far&quot;&gt;Results (so far)&lt;/h2&gt;

&lt;p&gt;First of all the code for the MyC64 project can be found &lt;a href=&quot;https://github.com/markus-zzz/myc64&quot;&gt;here on
github&lt;/a&gt; where the README contains a short
intruction sequence to get started with the simulator for those interested.&lt;/p&gt;

&lt;p&gt;Simulation is Verilator based and the driver program
&lt;a href=&quot;https://github.com/markus-zzz/myc64/blob/master/sim/c64-sim.cpp&quot;&gt;myc64-sim&lt;/a&gt; is
similar to the one used for &lt;a href=&quot;/2019/08/12/retro-gaming-hw-part-1.html&quot;&gt;my previous RetroCon project&lt;/a&gt; but with the addition of some nifty
features to execute delayed commands at a certain frame (e.g. no point
injecting a key press sequence until the system has finished booting).&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;markus@workstation:~/work/repos/myc64/sim$ ./myc64-sim -h
Usage: ./myc64-sim [OPTIONS]

  --scale=N             -- set pixel scaling
  --frame-rate=N        -- try to produce a new frame every N ms
  --save-frame-from=N   -- dump frames to .png starting from frame #N
  --save-frame-to=N=N   -- dump frames to .png ending with frame #N
  --save-frame-prefix=S -- prefix dump frame files with S
  --exit-after-frame=N  -- exit after frame #N
  --trace               -- create dump.vcd
  --cmd-load-prg=&amp;lt;FRAME&amp;gt;:&amp;lt;PRG&amp;gt;           -- wait until &amp;lt;FRAME&amp;gt; then load &amp;lt;PRG&amp;gt;
  --cmd-inject-keys=&amp;lt;FRAME&amp;gt;:&amp;lt;KEYS&amp;gt;       -- wait until &amp;lt;FRAME&amp;gt; then inject &amp;lt;KEYS&amp;gt;
  --cmd-dump-ram=&amp;lt;FRAME&amp;gt;:&amp;lt;ADDR&amp;gt;:&amp;lt;LENGTH&amp;gt; -- wait until &amp;lt;FRAME&amp;gt; then dump &amp;lt;LENGTH&amp;gt; bytes of RAM starting at &amp;lt;ADDR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;As an example consider the following command line that starts simulation and
then waits until video frame #135 before injecting the key sequence for the
classic one-line BASIC maze generator.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./myc64-sim --cmd-inject-keys=135:&quot;10&amp;lt;SPACE&amp;gt;PRINT&amp;lt;SPACE&amp;gt;CHR&amp;lt;LSHIFT&amp;gt;4&amp;lt;LSHIFT&amp;gt;8205.5+RND&amp;lt;LSHIFT&amp;gt;81&amp;lt;LSHIFT&amp;gt;9&amp;lt;LSHIFT&amp;gt;9;:GOTO&amp;lt;SPACE&amp;gt;10&amp;lt;RETURN&amp;gt;RUN&amp;lt;RETURN&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/download/c64/basic-maze.apng&quot; alt=&quot;C64 boot and one line BASIC maze&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It is also possible to inject an arbitrary &lt;code class=&quot;highlighter-rouge&quot;&gt;.prg&lt;/code&gt; file into memory and run
that. E.g. here we take a trivial program that cycles the background color and
assemble it into a &lt;code class=&quot;highlighter-rouge&quot;&gt;.prg&lt;/code&gt; file.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Start:
loop:  inc $d021
       jmp loop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cl65 -o test_001.prg -t c64 -C c64-asm.cfg -u __EXEHDR__ testasm/test_001.s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;It is interesting to note that the &lt;code class=&quot;highlighter-rouge&quot;&gt;cl65&lt;/code&gt; tool will also insert a small BASIC
header containing the necessary &lt;code class=&quot;highlighter-rouge&quot;&gt;SYS &amp;lt;addr&amp;gt;&lt;/code&gt; command so that the assembled
program can be started with a simple BASIC &lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt; command.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./myc64-sim --cmd-load-prg=130:test_001.prg --cmd-inject-keys=135:&quot;LIST&amp;lt;RETURN&amp;gt;RUN&amp;lt;RETURN&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/download/c64/cycle-bgcolor.apng&quot; alt=&quot;C64 cycle bgcolor&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next steps&lt;/h2&gt;

&lt;p&gt;I am reasonably happy with the result so far given the limited effort put in,
but of course it does not have to end here, this could evolve in any number of
different directions. Here are some ideas that come to mind&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Continue making the implementation more complete and exact, e.g. take a game such as &lt;a href=&quot;https://www.c64-wiki.com/wiki/Bubble_Bobble&quot;&gt;Bubble Bobble&lt;/a&gt; and try to make it play.&lt;/li&gt;
  &lt;li&gt;Get it running on the ULX3S. This would require putting the video frame in SDRAM so that HDMI/DVI can read it at the correct refresh rate for 640x480@60Hz. Also here we could find real use for &lt;a href=&quot;/2020/05/16/usb-dev-part-2.html&quot;&gt;the usbdev project&lt;/a&gt; to allow key and &lt;code class=&quot;highlighter-rouge&quot;&gt;.prg&lt;/code&gt; injection from a host PC.&lt;/li&gt;
  &lt;li&gt;Start looking at a SID implementation.&lt;/li&gt;
  &lt;li&gt;Rewrite in &lt;a href=&quot;https://github.com/m-labs/nmigen&quot;&gt;nMigen&lt;/a&gt;. For quite some time now I have been wanting to try out nMigen on a project and this might be a good opportunity.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That is it for this post. If you have questions or feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">When I was a kid back in the 80s my parents bought our family’s first computer, a Commodore 64 with a datasette station. I still have fond memories of that marvelous little machine. At the time though I was only ten years old so my mental capacity (and likely also patience) was quite limited and I never managed to do much with it besides playing games and typing in the occasional BASIC listing from the Sunday newspaper (that almost never worked).</summary></entry><entry><title type="html">Building a USB device part-2</title><link href="https://www.zzzconsulting.se/2020/05/16/usb-dev-part-2.html" rel="alternate" type="text/html" title="Building a USB device part-2" /><published>2020-05-16T00:00:00+02:00</published><updated>2020-05-16T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2020/05/16/usb-dev-part-2</id><content type="html" xml:base="https://www.zzzconsulting.se/2020/05/16/usb-dev-part-2.html">&lt;p&gt;In this post we pick up where we left of last time and start looking at the
design and implementation of the USB device that I have been working on. First
things first though, the code for the entire project can be found in &lt;a href=&quot;https://github.com/markus-zzz/usbdev/tree/dev&quot;&gt;this
github repository&lt;/a&gt;. The reader
is advised to have that readily available.&lt;/p&gt;

&lt;p&gt;The first major goal of this series will be to have the device play along
during the USB enumeration process so that the host can set address and read
relevant descriptors. This can be verified by making sure that the device shows
up properly when issuing a  &lt;code class=&quot;highlighter-rouge&quot;&gt;lsusb&lt;/code&gt; on my Linux workstation.&lt;/p&gt;

&lt;h2 id=&quot;design-of-usbdev-and-soc&quot;&gt;Design of usbdev (and SoC)&lt;/h2&gt;

&lt;h3 id=&quot;clock-recovery&quot;&gt;Clock recovery&lt;/h3&gt;

&lt;p&gt;The signaling in USB consists of the differential pair D+ and D-. For a &lt;em&gt;full
speed (FS)&lt;/em&gt; device the bit rate is 12Mbit/s so if we were able to sample at
exactly the right spot a 12Mhz clock should suffice, in reality though this is
the tricky bit. To aid in clock recovery USB employs both NRZI encoding and
bit-stuffing to ensure that the differential pair will contain a level
transition at least every seven bit times.&lt;/p&gt;

&lt;p&gt;With this in mind it would seem a reasonable approach to run the design at
48Mhz and oversample the differential pair with a factor of four. More
precisely by obtaining four equally spaced samples for each bit time we should
be able to adjust the actual sampling position (in terms of 1/4 bit times) to be
as far away for any level transition as possible (i.e. in the middle of the eye
diagram).&lt;/p&gt;

&lt;p&gt;So running at a 48Mhz clock we have a 2-bit counter (&lt;code class=&quot;highlighter-rouge&quot;&gt;reg [1:0] cntr&lt;/code&gt;)
incrementing each cycle (except for when adjusting). When the counter equals
zero we perform the real sample. For every 48Mhz cycle we also sample and shift
the value into a four bit shift register (&lt;code class=&quot;highlighter-rouge&quot;&gt;reg [3:0] past&lt;/code&gt;). Since we want any
possible level transition to occur in the middle of this shift register we
either advance or delay the counter with one increment depending on if a
transition occurred early or late in the shift register.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // A bit transition should ideally occur between past[2] and past[1]. If it
  // occurs elsewhere we are either sampling too early or too late.
  assign advance = past[3] ^ past[2];
  assign delay   = past[1] ^ past[0];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;advance&lt;/code&gt; is active the counter increments by two and if &lt;code class=&quot;highlighter-rouge&quot;&gt;delay&lt;/code&gt; is active
there is no increment (for the given 48Mhz cycle).&lt;/p&gt;

&lt;p&gt;After seeing some transitions this should be able to adjust the sampling point
to where the signal lines are stable.&lt;/p&gt;

&lt;p&gt;This is not the only option for clock recovery though but it is the simplest
one to implement. However if the bit rate was significantly higher compared to
the frequency our design is clocked at (e.g. USB &lt;em&gt;high-speed&lt;/em&gt; at 480Mbit/s)
other methods would have to be used. In such cases I would suspect that
sampling at the exact bit rate and then phase adjusting the clock (with help of
a PLL) until the synchronization pattern is reliably detected would be the
method of choice. Of course simply phase adjusting until the synchronization
pattern is detected would not be enough, you probably want a FSM to find the
midpoint of highest and lowest phase adjustment that makes the pattern
detectable.&lt;/p&gt;

&lt;p&gt;A variant of the previous approach would be to use adjustable delay lines on
the inputs instead of phase adjusting the clock.&lt;/p&gt;

&lt;h3 id=&quot;the-hwsw-interface&quot;&gt;The HW/SW interface&lt;/h3&gt;

&lt;p&gt;To control the USB block some kind of hardware/software interface needs to be
created. I have chosen the simplest possible design that came to mind.&lt;/p&gt;

&lt;p&gt;Each endpoint has a 8 byte buffer in RAM, starting at RAM address zero comes
the 16 OUT endpoints immediately followed by the 16 IN endpoints. In total 256
bytes of RAM are used for endpoint buffers.&lt;/p&gt;

&lt;p&gt;In addition the following registers are exposed to the CPU.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Register&lt;/th&gt;
      &lt;th&gt;Access&lt;/th&gt;
      &lt;th&gt;Address&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;R_USB_ADDR&lt;/td&gt;
      &lt;td&gt;R/W&lt;/td&gt;
      &lt;td&gt;0x20000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R_USB_ENDP_OWNER&lt;/td&gt;
      &lt;td&gt;R/W&lt;/td&gt;
      &lt;td&gt;0x20000004&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R_USB_CTRL&lt;/td&gt;
      &lt;td&gt;W&lt;/td&gt;
      &lt;td&gt;0x20000008&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R_USB_IN_SIZE_0_7&lt;/td&gt;
      &lt;td&gt;R/W&lt;/td&gt;
      &lt;td&gt;0x2000000C&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R_USB_IN_SIZE_8_15&lt;/td&gt;
      &lt;td&gt;R/W&lt;/td&gt;
      &lt;td&gt;0x20000010&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R_USB_DATA_TOGGLE&lt;/td&gt;
      &lt;td&gt;R/W&lt;/td&gt;
      &lt;td&gt;0x20000014&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R_USB_OUT_SIZE_0_7&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;0x20000018&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R_USB_OUT_SIZE_8_15&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;0x2000001C&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I have not bothered documenting them in detail yet but essentially it is as follows.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;R_USB_ADDR&lt;/em&gt; - is the 7-bit device address.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;R_USB_ENDP_OWNER&lt;/em&gt; - The 16 low bits correspond to the 16 OUT endpoints and the 16 high bits correspond to the 16 IN endpoints. A set bit indicates that the corresponding endpoint buffer is handed over to the USB block. This means that the corresponding endpoint will accept one IN/OUT packet (with data) and ACK, after which the bit will be cleared and the buffer is handed over to the CPU. When the CPU owns a buffer the USB block will respond with NAK to all IN/OUT+DATA packets.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;R_USB_CTRL&lt;/em&gt; - Control pull-ups for attach.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;R_USB_IN_SIZE_0_7&lt;/em&gt; - 4-bits per endpoint indicate the number of bytes in the corresponding buffer.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;R_USB_IN_SIZE_8_15&lt;/em&gt; - 4-bits per endpoint indicate the number of bytes in the corresponding buffer.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;R_USB_DATA_TOGGLE&lt;/em&gt; - The 16 low bits select the data toggle (DATA0/DATA1) to be expected for the 16 OUT endpoints and the 16 high bits select the data toggle to be sent for the 16 IN endpoints.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;R_USB_OUT_SIZE_0_7&lt;/em&gt; - 4-bits per endpoint indicate the number of bytes in the corresponding buffer.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;R_USB_OUT_SIZE_8_15&lt;/em&gt; - 4-bits per endpoint indicate the number of bytes in the corresponding buffer.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course a primitive interface like this requires a fair amount of CPU
intervention and if one wants to offload the CPU and achieve higher performance
a lot of this handling could be automated by the USB block itself.&lt;/p&gt;

&lt;h3 id=&quot;soc&quot;&gt;SoC&lt;/h3&gt;

&lt;p&gt;The resulting SoC consists of the USB device block, a PicoRV32 RISCV CPU, RAM
and ROM. From the CPU’s side the memory map is as follows.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Base&lt;/th&gt;
      &lt;th&gt;Size&lt;/th&gt;
      &lt;th&gt;Memory&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0x00000000&lt;/td&gt;
      &lt;td&gt;16KB&lt;/td&gt;
      &lt;td&gt;ROM&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x10000000&lt;/td&gt;
      &lt;td&gt;4KB&lt;/td&gt;
      &lt;td&gt;RAM&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x20000000&lt;/td&gt;
      &lt;td&gt;32B&lt;/td&gt;
      &lt;td&gt;USB control &amp;amp; status registers&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The USB device block’s endpoint buffers reside in RAM and the block has
priority over the CPU when accessing. RAM is constructed of four 8-bit banks.
The CPU is connected by a 32-bit bus while the USB block has a 8-bit bus. As
mentioned USB has priority when accessing RAM but in practice this should
result in minimal stall cycles for the CPU as its clock is significantly higher
than the rate of which USB will read/write bytes.&lt;/p&gt;

&lt;h2 id=&quot;simulation&quot;&gt;Simulation&lt;/h2&gt;

&lt;p&gt;The simulation environment is based around Verilator and a set of C++ classes
to build, manipulate and dissect USB packets.&lt;/p&gt;

&lt;h3 id=&quot;usb-pack-gen&quot;&gt;usb-pack-gen&lt;/h3&gt;

&lt;p&gt;The USB packet generation and manipulation code is found in
&lt;a href=&quot;https://github.com/markus-zzz/usbdev/blob/dev/sim/usb-pack-gen.h&quot;&gt;sim/usb-pack-gen.h&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/markus-zzz/usbdev/blob/dev/sim/usb-pack-gen.cpp&quot;&gt;sim/usb-pack-gen.cpp&lt;/a&gt;. It allows both encoding and decoding of USB packets. In essence it consists of three layers&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UsbPacket - Base class for the various USB packet types (SETUP,IN,OUT,DATA0,DATA1,ACK,NAK) that allow easy high level manipulation. UsbPacket is derived into the various packet types.&lt;/li&gt;
  &lt;li&gt;USbBitVector - A sequence of USB bits.&lt;/li&gt;
  &lt;li&gt;UsbSymbolVector - A sequence of USB symbols (J,K,SE0,SE1).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are methods for translating in both directions performing the necessary
steps such as CRC calculation, bit-stuffing and NRZI encoding.&lt;/p&gt;

&lt;h3 id=&quot;test-suite&quot;&gt;Test-suite&lt;/h3&gt;

&lt;p&gt;The test-suite is invoked by the &lt;code class=&quot;highlighter-rouge&quot;&gt;sim/runner.pl&lt;/code&gt; script that will execute all
tests found in &lt;code class=&quot;highlighter-rouge&quot;&gt;sim/tests&lt;/code&gt; (or the ones given as argument). Each
&lt;code class=&quot;highlighter-rouge&quot;&gt;sim/tests/test_XXX.c&lt;/code&gt; consists of both firmware code to be compiled for the
RISCV CPU as well as usb-pack-gen code compiled into the Verilator based
simulation environment.&lt;/p&gt;

&lt;p&gt;To get a feel for what a test looks like I suggest studying
&lt;a href=&quot;https://github.com/markus-zzz/usbdev/blob/dev/sim/tests/test_003.c&quot;&gt;sim/tests/test_003.c&lt;/a&gt;.
It is probably a good idea to start with running the test and looking at the
decoded USB traffic.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./runner.pl tests/test_003.c
sigrok-cli -i test_003.sim.sr -P usb_signalling:dp=0:dm=1,usb_packet | awk '/usb_packet-1: [^:]+$/{ print $0 }'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Should give us something like this (but without the host/device annotations I
added manually).&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;host   : OUT ADDR 0 EP 0
host   : DATA0 [ 23 64 54 AF CA FE ]
device : ACK
host   : IN ADDR 0 EP 1
device : NAK
host   : IN ADDR 0 EP 1
device : DATA0 [ 24 65 55 B0 CB FF ]
host   : ACK
host   : IN ADDR 0 EP 1
device : NAK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So the host sends six bytes of data to endpoint zero and the device
acknowledges it. The host tries to read from endpoint one but the device is
busy (the dummy loop reading the address register) so responds with a not
acknowledge. The host tries to read again and this time the device responds
with the byte array with each element incremented by one. The host acknowledges
the received data. The host tries to read yet again but now the endpoint buffer
has been handed back to the CPU so the USB block responds with not acknowledge.&lt;/p&gt;

&lt;p&gt;Now with this in mind it should be rather clear what is going on in the test
case.&lt;/p&gt;

&lt;h3 id=&quot;test-suite-artifacts&quot;&gt;Test-suite artifacts&lt;/h3&gt;

&lt;p&gt;When run the test-suite outputs several useful artifacts. These are&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;test_XXX.comp.log - Any messages (errors and warnings) from the firmware compile.&lt;/li&gt;
  &lt;li&gt;test_XXX.sim.log - Log and debug printouts from the simulation.&lt;/li&gt;
  &lt;li&gt;test_XXX.sim.vcd - RTL simulation waveform in VCD format.&lt;/li&gt;
  &lt;li&gt;test_XXX.sim.sr - Captured USB signaling in sigrok’s format.&lt;/li&gt;
  &lt;li&gt;test_XXX.elf - Firmware code for the RISCV CPU.&lt;/li&gt;
  &lt;li&gt;test_XXX.so - Shared object with test-case code to be loaded into the simulator.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-real-world-example&quot;&gt;A real world example&lt;/h2&gt;

&lt;p&gt;I thought we finish this post by using some work-in-progress driver code
(&lt;a href=&quot;https://github.com/markus-zzz/usbdev/blob/dev/sw/usb-dev-driver.c&quot;&gt;sw/usb-dev-driver.c&lt;/a&gt;)
to perform the first steps of the USB enumeration process with the ULX3S
connected to my Linux workstation. The logic analyzer captured the following
&lt;a href=&quot;https://www.zzzconsulting.se/download/sigrok-usb/ulx3s-usbdev-1.sr&quot;&gt;trace&lt;/a&gt; (5M samples at 5Mhz
but only 68KB file size with sigrok’s native format). The reader is urged to
decode it by at least using&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sigrok-cli -i ulx3s-usbdev-1.sr -P usb_signalling:dp=1:dm=0,usb_packet | awk '/usb_packet-1: [^:]+$/{ print $0 }'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;but preferably also in PulseView to better see reset signaling etc.&lt;/p&gt;

&lt;p&gt;In summary the following happens in the trace. The host resets the bus, the
device descriptor is read, the host resets the bus, the host sets the device’s
address to 23, the host reads the device descriptor once again, the host reads
the configuration descriptor (first nine bytes only to figure out total size),
the host reads the total size of the configuration descriptor (which includes
interface and endpoint descriptors but in our case there are none so the size
is still 9 bytes). Finally the host tries to set the configuration of the
device but this is not yet implemented in the firmware and the device responds
with NAK indefinitely.&lt;/p&gt;

&lt;p&gt;On my Linux workstation the &lt;code class=&quot;highlighter-rouge&quot;&gt;dmesg&lt;/code&gt; log contained the following lines&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ 2980.864737] usb 1-5: new low-speed USB device number 16 using xhci_hcd
[ 2981.014361] usb 1-5: config 0 has no interfaces?
[ 2981.014369] usb 1-5: New USB device found, idVendor=1234, idProduct=5678
[ 2981.014372] usb 1-5: New USB device strings: Mfr=0, Product=0, SerialNumber=0
[ 2981.014647] usb 1-5: config 0 descriptor??
[ 2986.192817] usb 1-5: can't set config #0, error -110
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and a &lt;code class=&quot;highlighter-rouge&quot;&gt;lsusb -v&lt;/code&gt; contained&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Bus 001 Device 016: ID 1234:5678 Brain Actuated Technologies
Couldn't open device, some information will be missing
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
  bDeviceClass          255 Vendor Specific Class
  bDeviceSubClass       255 Vendor Specific Subclass
  bDeviceProtocol       255 Vendor Specific Protocol
  bMaxPacketSize0         8
  idVendor           0x1234 Brain Actuated Technologies
  idProduct          0x5678
  bcdDevice            1.00
  iManufacturer           0
  iProduct                0
  iSerial                 0
  bNumConfigurations      1
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength            9
    bNumInterfaces          0
    bConfigurationValue     0
    iConfiguration          0
    bmAttributes         0x80
      (Bus Powered)
    MaxPower              100mA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;As can be seen my made up &lt;em&gt;idVendor&lt;/em&gt; actually corresponded to a registered vendor
as can be confirmed in &lt;a href=&quot;http://www.linux-usb.org/usb.ids&quot;&gt;Linux usb.ids&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Slightly strange though is that &lt;code class=&quot;highlighter-rouge&quot;&gt;lsusb&lt;/code&gt; claims that the device address is 16
while the trace clearly contains a &lt;em&gt;SET_ADDRESS&lt;/em&gt; and subsequent use of
  address 23.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next steps&lt;/h2&gt;

&lt;p&gt;The logical next steps would be to continue working on the driver code until
the enumeration process completes successfully supporting all required
requests. Likely some RTL bugs will show up in the process but we will try to
deal with them when they do.&lt;/p&gt;

&lt;p&gt;That is it for today. As always if you have questions or feedback - leave a
comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">In this post we pick up where we left of last time and start looking at the design and implementation of the USB device that I have been working on. First things first though, the code for the entire project can be found in this github repository. The reader is advised to have that readily available.</summary></entry><entry><title type="html">Sigrok and thoughts on building a USB device</title><link href="https://www.zzzconsulting.se/2020/04/25/sigrok-usb-dev.html" rel="alternate" type="text/html" title="Sigrok and thoughts on building a USB device" /><published>2020-04-25T00:00:00+02:00</published><updated>2020-04-25T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2020/04/25/sigrok-usb-dev</id><content type="html" xml:base="https://www.zzzconsulting.se/2020/04/25/sigrok-usb-dev.html">&lt;p&gt;Last summer I bought a &lt;a href=&quot;https://www.dreamsourcelab.com/product/dslogic-plus/&quot;&gt;DSLogic
Plus&lt;/a&gt; USB-based Logic
Analyzer, about 6 months ago I tried it for the first time and today I hope to
finish this post describing the experience. The thing comes with its own
analyzer software running on the PC called
&lt;a href=&quot;https://www.dreamsourcelab.com/download/&quot;&gt;DSView&lt;/a&gt;, but I never bothered trying
that and instead went with the better known &lt;a href=&quot;https://sigrok.org/&quot;&gt;sigrok&lt;/a&gt; (of
which DSView is a derivative).&lt;/p&gt;

&lt;h2 id=&quot;setting-up-sigrok-for-the-dslogic-plus&quot;&gt;Setting up sigrok for the DSLogic Plus&lt;/h2&gt;

&lt;p&gt;Building from source seemed rather complicated with many dependencies to be
met, but luckily they also provide self contained
&lt;a href=&quot;https://appimage.org/&quot;&gt;AppImage&lt;/a&gt; binaries for download
&lt;a href=&quot;https://sigrok.org/wiki/Downloads&quot;&gt;here&lt;/a&gt;. So I picked up a &lt;em&gt;PulseView&lt;/em&gt; and a
&lt;em&gt;sigrok-cli&lt;/em&gt; binary.&lt;/p&gt;

&lt;p&gt;Although being self contained two additional steps were required to get things
going.&lt;/p&gt;

&lt;p&gt;First setting up udev rules&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone git://sigrok.org/libsigrok
cp libsigrok/contrib/*.rules /etc/udev/rules.d/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and second, due to legal reasons, the self contained sigrok binaries do not
contain the necessary firmware for the DSLogic Plus so we need to grab a script
that fetches those separately&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone git://sigrok.org/sigrok-util
sudo sigrok-util/firmware/dreamsourcelab-dslogic/sigrok-fwextract-dreamsourcelab-dslogic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;test-capture&quot;&gt;Test capture&lt;/h2&gt;

&lt;p&gt;Attaching to the USB &lt;strong&gt;D+&lt;/strong&gt; and &lt;strong&gt;D-&lt;/strong&gt; of a STM32 based thumb device and
capturing the signaling that occurs when the device is connected to the bus.&lt;/p&gt;

&lt;p&gt;For background on USB 2.0 the spec summary &lt;a href=&quot;https://www.beyondlogic.org/usbnutshell/usb1.shtml&quot;&gt;USB in a
NutShell&lt;/a&gt; is a highly
recommended read, the similar summary &lt;a href=&quot;http://www.usbmadesimple.co.uk/&quot;&gt;USB Made
Simple&lt;/a&gt; also provides very valuable
information. For all the gory details the full specification is available
&lt;a href=&quot;https://www.usb.org/document-library/usb-20-specification&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Sigrok provides a very neat protocol decoder for USB (as well as for many other
protocols).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/download/sigrok-usb/sigrok-usb-decode.png&quot; alt=&quot;PulseView USB decode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It is interesting to observe what happens when a new device is connected&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Newly connected device has address 0.
host   : SETUP ADDR 0 EP 0
host   : DATA0 [ 80 06 00 01 00 00 40 00 ]
device : ACK
host   : IN ADDR 0 EP 0
device : NAK
host   : IN ADDR 0 EP 0
device : DATA1 [ 12 01 00 02 02 02 00 40 83 04 40 57 00 02 01 02 03 01 ]
host   : ACK

host   : OUT ADDR 0 EP 0
host   : DATA1 [ ]
device : NAK
host   : OUT ADDR 0 EP 0
host   : DATA1 [ ]
device : ACK

host: &amp;lt;RESET for 50ms&amp;gt;

# SET_ADDRESS (=0x05) to 10 (=0x0A)
host   : SETUP ADDR 0 EP 0
host   : DATA0 [ 00 05 0A 00 00 00 00 00 ]
device : ACK
host   : IN ADDR 0 EP 0
device : NAK
host   : IN ADDR 0 EP 0
device : DATA1 [ ]
device : ACK

# From this point on the device has address 10.

host   : SETUP ADDR 10 EP 0
host   : DATA0 [ 80 06 00 01 00 00 12 00 ]
device : ACK
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;what appears to be going on here is that the host begins by reading the &lt;em&gt;device
descriptor&lt;/em&gt; containing, among other things, the highest USB version this device
supports, &lt;em&gt;idVendor&lt;/em&gt; and &lt;em&gt;idProduct&lt;/em&gt;. If these are satisfactory the host
goes ahead and drives a long reset followed by assigning the device a new
address.&lt;/p&gt;

&lt;p&gt;A simple &lt;code class=&quot;highlighter-rouge&quot;&gt;lsusb&lt;/code&gt; confirms that &lt;em&gt;idVendor&lt;/em&gt; and &lt;em&gt;idProduct&lt;/em&gt; appear in the
response message retrieved before the reset.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Bus 001 Device 010: ID 0483:5740 STMicroelectronics STM32F407
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;thoughts-on-building-a-usb-device&quot;&gt;Thoughts on building a USB device&lt;/h2&gt;

&lt;p&gt;If you are so inclined you might now wonder what kind of digital circuitry it
would take to build a USB device. Common sense says this would be a rather
significant undertaking so it seems wise to begin with some preparatory
considerations.&lt;/p&gt;

&lt;h3 id=&quot;ulx3s-setup&quot;&gt;ULX3S setup&lt;/h3&gt;

&lt;p&gt;As usual the platform for my experiment will be the excellent
&lt;a href=&quot;https://radiona.org/ulx3s/&quot;&gt;ULX3S&lt;/a&gt;. The board has two USB micro female
connectors where the second (designated US2) is wired directly to the ECP5
FPGA.&lt;/p&gt;

&lt;h4 id=&quot;schematics&quot;&gt;Schematics&lt;/h4&gt;

&lt;p&gt;Full schematics are found
&lt;a href=&quot;https://github.com/emard/ulx3s/blob/master/doc/schematics.pdf&quot;&gt;here&lt;/a&gt; but for
the sake of this discussion I have extracted the relevant parts.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/download/sigrok-usb/ulx3s-schematics-usb-1.png&quot; alt=&quot;ULX3S US2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What is interesting to note here is that the &lt;em&gt;USB_FPGA_D+&lt;/em&gt; and &lt;em&gt;USB_FPGA_D-&lt;/em&gt;
pair is connected to the FPGA twice. One pair is connected to a differential
IO cell and the second pair is connected to single ended IO cells. Reason is
that USB requires us to both drive and sample differential as well as single
ended. Still weird though as ECP5 docs kind of suggest that all of that could
be done within one IO cell (pair).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/download/sigrok-usb/ulx3s-schematics-usb-2.png&quot; alt=&quot;ULX3S US2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The second interesting part is that the board has FPGA controllable pull-ups.
This allows us to attach/detach from the USB without physically touching any
cables. As well as choosing if we want to identify as a &lt;em&gt;full-speed&lt;/em&gt; or
&lt;em&gt;low-speed&lt;/em&gt; device.&lt;/p&gt;

&lt;h4 id=&quot;clocking&quot;&gt;Clocking&lt;/h4&gt;

&lt;p&gt;USB &lt;em&gt;full-speed&lt;/em&gt; is 12Mbit/s and USB &lt;em&gt;low-speed&lt;/em&gt; is 1.5Mbit/s, the ULX3S board
has a 25Mhz crystal oscillator.&lt;/p&gt;

&lt;p&gt;For &lt;em&gt;full-speed&lt;/em&gt; if we were to sample at exactly the right spot a 12Mhz clock
should suffice, but in reality this is not possible (without phase adjusting
the clock). So instead one typically settles for oversampling with a factor of
four (so a 48Mhz clock would be needed).&lt;/p&gt;

&lt;p&gt;Now a 25Mhz clock does not directly PLL into a 48Mhz clock (nor any other
reasonable multiple of 12Mhz). It does however PLL it into a 15Mhz clock that
can be used for &lt;em&gt;low-speed&lt;/em&gt; (oversampling with a factor 10).&lt;/p&gt;

&lt;p&gt;Eventually though for &lt;em&gt;full-speed&lt;/em&gt; we can use two PLLs in cascade configured as
follows to reach exactly 48Mhz.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;markus@workstation:~$ ecppll -i 25 -o 60
Pll parameters:
Refclk divisor: 5
Feedback divisor: 12
clkout0 divisor: 10
clkout0 frequency: 60 MHz
VCO frequency: 600
markus@workstation:~$ ecppll -i 60 -o 48
Pll parameters:
Refclk divisor: 5
Feedback divisor: 4
clkout0 divisor: 12
clkout0 frequency: 48 MHz
VCO frequency: 576
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;connecting-the-logic-analyzer&quot;&gt;Connecting the Logic Analyzer&lt;/h4&gt;

&lt;p&gt;A sturdy attachment point for the analyzer is desirable as it is rather
annoying having test hook clips constantly falling off the board as soon as it
is moved/touched only the slightest.&lt;/p&gt;

&lt;p&gt;Luckily since it is a FPGA we can route the &lt;em&gt;USB_FPGA_D+&lt;/em&gt; and &lt;em&gt;USB_FPGA_D-&lt;/em&gt;
pair “out on the other side” to make it available on the pin header. This is
mechanically stable and has the additional advantage of being isolated from the
actual signals so there is no risk of interference from the analyzer probes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/download/sigrok-usb/ulx3s-pin-header.jpg&quot; alt=&quot;ULX3S US2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;sigrok-support&quot;&gt;Sigrok support&lt;/h3&gt;

&lt;p&gt;Having powerful tools such as the Sigrok suite and the Logic Analyzer will
prove invaluable for the task ahead. In fact, as we shall soon see, they will be
useful in not only the obvious way.&lt;/p&gt;

&lt;p&gt;Capture signaling/traffic between the USB host and FPGA would be the obvious
application and while this will eventually be its main use we need to get quite
a lot of things working to reach that point.&lt;/p&gt;

&lt;p&gt;In the meantime we can capture authentic host signaling and feed into RTL
simulation. Doing so can be easily accomplished with&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sigrok-cli --input-file capture.sr -O csv | awk 'BEGIN{FS=&quot;,&quot;}{print $2$3}' - &amp;gt; capture.vh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and initializing the Verilog array with &lt;em&gt;$readmemb&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;However this presents an issue with mismatch in sampling rate. The closest the
analyzer can come to 48Mhz is 50Mhz so this will be an issue for the USB
device’s clock recovery.&lt;/p&gt;

&lt;p&gt;To avoid the sampling rate mismatch another option is to have sigrok run the
low level &lt;em&gt;usb-signalling&lt;/em&gt; decoder to reliably extract the &lt;em&gt;J&lt;/em&gt;, &lt;em&gt;K&lt;/em&gt;, &lt;em&gt;SE0&lt;/em&gt; and
&lt;em&gt;SE1&lt;/em&gt; symbols for us. To do this we use the follow python snippet to translate&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#!/usr/bin/env python
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;re&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;pattern_j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;^usb_signalling-1: J$&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pattern_k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;^usb_signalling-1: K$&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pattern_se0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;^usb_signalling-1: SE0$&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pattern_se1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;^usb_signalling-1: SE1$&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pattern_j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'01'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pattern_k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'10'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pattern_se0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'00'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pattern_se1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'11'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and then run the entire chain&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sigrok-cli -i capture.sr -P usb_signalling:dp=1:dm=0 | ./usb_signalling2vh.py &amp;gt; capture.vh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once our RTL simulation generates USB signaling we can feed that into sigrok
for decode and verification. It is just a matter of having simulation produce a
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma-separated_values&quot;&gt;CSV&lt;/a&gt; file and then&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sigrok-cli -i capture.csv -I csv:samplerate=48000000 -o capture.sr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;where the file &lt;code class=&quot;highlighter-rouge&quot;&gt;capture.sr&lt;/code&gt; can be opened and graphically decoded in
&lt;em&gt;PulseView&lt;/em&gt;. Pretty awesome!&lt;/p&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h2&gt;

&lt;p&gt;That concludes this post. Next time we will look closer at the design of our
USB device, its simulation environment and traffic generator. Questions or
feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">Last summer I bought a DSLogic Plus USB-based Logic Analyzer, about 6 months ago I tried it for the first time and today I hope to finish this post describing the experience. The thing comes with its own analyzer software running on the PC called DSView, but I never bothered trying that and instead went with the better known sigrok (of which DSView is a derivative).</summary></entry><entry><title type="html">Designing retro gaming hardware - part 1</title><link href="https://www.zzzconsulting.se/2019/08/12/retro-gaming-hw-part-1.html" rel="alternate" type="text/html" title="Designing retro gaming hardware - part 1" /><published>2019-08-12T00:00:00+02:00</published><updated>2019-08-12T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2019/08/12/retro-gaming-hw-part-1</id><content type="html" xml:base="https://www.zzzconsulting.se/2019/08/12/retro-gaming-hw-part-1.html">&lt;p&gt;In this post we visit my latest pet project - that is building a custom 80’s
style game console. Much fun ahead :)&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;
&lt;p&gt;The main motivating factor behind this effort was seeing the game &lt;a href=&quot;https://www.lexaloffle.com/bbs/?tid=2145&quot;&gt;Celeste
(classic)&lt;/a&gt; running on the
&lt;a href=&quot;https://www.lexaloffle.com/pico-8.php&quot;&gt;Pico-8&lt;/a&gt; fantasy console. This game is
in fact the precursor of the very well received 2018’s title
&lt;a href=&quot;http://www.celestegame.com/&quot;&gt;Celeste&lt;/a&gt; and Pico-8 is a software emulator for a
80’s game console that never existed. The limited environment offered by such a
machine has made it quite popular among makers of small games as it turns out
that having limited resources really can be a good thing when it comes to
finishing a game project.&lt;/p&gt;

&lt;p&gt;One of the many cool things with Pico-8 is that the cartridge for any game
distributed is automatically open and its contents (sprites, tiles and maps as
well as source code) can be examined by anyone, either through the builtin
Pico-8 IDE or using the python
&lt;a href=&quot;https://github.com/dansanderson/picotool&quot;&gt;picotool&lt;/a&gt; module.&lt;/p&gt;

&lt;p&gt;I for one find this game to be truly awesome and I am really impressed with how
well it plays even with such limited resources. As a result the goal of my
project is now to design 80’s style sprite and tile based video game hardware
that is capable of playing a game like this and run it on a FPGA.&lt;/p&gt;

&lt;h2 id=&quot;design&quot;&gt;Design&lt;/h2&gt;

&lt;p&gt;Lets begin by looking at the major components of the system.&lt;/p&gt;

&lt;h3 id=&quot;graphics&quot;&gt;Graphics&lt;/h3&gt;
&lt;p&gt;First there is no frame buffer (remember at this time memory is expensive and
CPUs are slow). Instead all graphics are produced on the fly having dedicated
hardware shift out pixel by pixel of movable sprites and stationary background
tiles as the video beam traces along the screen.&lt;/p&gt;

&lt;p&gt;The lowest video resolution broadly supported by modern display hardware is
640x480@60Hz. The video timing generator for such a resolution uses a 25Mhz
pixel clock which is also quite suitable to base the rest of our design on.&lt;/p&gt;

&lt;p&gt;For a retro system 640x480 is too high resolution so we cut it down to 320x240
by ignoring the lowest bit of the vertical video coordinate (so that even and
odd scanlines will look the same) and introducing a clock enable (set by the
lowest bit of the horizontal video coordinate) to have the sprite and tile
shifters keep the same pixel value for two consecutive horizontal video pixels.&lt;/p&gt;

&lt;p&gt;A sprite/tile in Pico-8 is 8x8 pixels and a pixel holds 4 bits of color
information. We will do the same.&lt;/p&gt;

&lt;p&gt;A sprite shifter module is basically a shift register combined with some
triggering logic to make the shifting start only when a programmed horizontal
position is reached.&lt;/p&gt;

&lt;p&gt;Our system has eight sprite shifters and each of these need to be loaded per
scanline before the visual region starts. As soon as a scanline starts (or
rather when the previous one reached position 320) a FSM takes care of
performing the following steps&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Scan the 64 entry sprite descriptor table in VRAM to find the first eight that
have sprites intersecting the current scanline. While doing this load the
corresponding sprite lines into the sprite shifters and set the horizontal
trigger position.&lt;/li&gt;
  &lt;li&gt;When the active region starts load the corresponding tile line into the tile
shifter based simply on the contents of the VRAM tile table.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The sprite descriptor format is:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Field&lt;/th&gt;
      &lt;th&gt;Bits&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;vpos&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Vertical start position (0-319).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hpos&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Horizontal start position (0-239).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;idx&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;Index of sprite (0-127).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;vflip&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Flip pixels vertically.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hflip&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Flip pixels horizontally.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;active&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Display sprite.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;vram&quot;&gt;VRAM&lt;/h3&gt;
&lt;p&gt;As is customary the graphics system has its own memory (VRAM) to which it has
exclusive access (CPU will stall if it tries to access) except for during the
vertical blanking period when the CPU gets to update sprite descriptors and
tile tables.&lt;/p&gt;

&lt;h4 id=&quot;rationale-behind-dimension-and-memory-map&quot;&gt;Rationale behind dimension and memory map&lt;/h4&gt;

&lt;p&gt;Each sprite/tile is 8x8 pixel with a color depth of 4 bits giving it a
storage requirement of 32 bytes. We need at least 128 of these in VRAM so
that results in 4096 bytes.&lt;/p&gt;

&lt;p&gt;Each sprite descriptor is 32 bits wide and we need 64 of those, i.e. 256
bytes.&lt;/p&gt;

&lt;p&gt;With a screen resolution of 320x200 and sprite/tile size of 8x8 a total of
40x30 tiles are needed to cover the screen using a 8 bit index for each results
in 1200 bytes. Since we want to be able to index this memory without performing
multiplication the dimension is rounded up to the nearest power-of-two i.e.
64x32 resulting in 2048 bytes (in fact the storage size can be much less
depending on if this is row major or column major).&lt;/p&gt;

&lt;p&gt;The extra rows and columns may come in handy whey trying to support smooth
scrolling.&lt;/p&gt;

&lt;p&gt;All in all it is reasonable to dimension the VRAM to 8192 bytes. To allow
efficient 32 bit access from both GFX and CPU this is laid out as 2048 x
32 meaning that we need an address bus width of 11 bits.&lt;/p&gt;

&lt;p&gt;So to sum it up VRAM is laid out as follows:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Base&lt;/th&gt;
      &lt;th&gt;Size&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;4096&lt;/td&gt;
      &lt;td&gt;Table of 128 8x8 sprite/tile bitmaps with 4-bit color depth (each bitmap consumes 32 bytes).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4096&lt;/td&gt;
      &lt;td&gt;256&lt;/td&gt;
      &lt;td&gt;Table of 64 sprite descriptors each of size 32 bits.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4352&lt;/td&gt;
      &lt;td&gt;2048&lt;/td&gt;
      &lt;td&gt;40x30 table of background tile indices (addressed as if dimensions were 64x32).&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;cpu&quot;&gt;CPU&lt;/h3&gt;
&lt;p&gt;One thing that is not so awesome about 80’s systems is the software tools
available (especially compilers), so instead of using a CPU from the era this
project will use a modern &lt;a href=&quot;https://riscv.org/&quot;&gt;RISC-V&lt;/a&gt; 32-bit CPU which is well
supported by modern tool-chains such as LLVM and GCC. The particular RISC-V
implementation of choice is
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; as we favor small size
over computational efficiency.&lt;/p&gt;

&lt;h3 id=&quot;system-memory-map&quot;&gt;System memory map&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Base&lt;/th&gt;
      &lt;th&gt;Size&lt;/th&gt;
      &lt;th&gt;Memory&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0x00000000&lt;/td&gt;
      &lt;td&gt;16KB&lt;/td&gt;
      &lt;td&gt;ROM&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x10000000&lt;/td&gt;
      &lt;td&gt;4KB&lt;/td&gt;
      &lt;td&gt;RAM&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x20000000&lt;/td&gt;
      &lt;td&gt;8KB&lt;/td&gt;
      &lt;td&gt;VRAM&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x30000000&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;System status register&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;current-implementation&quot;&gt;Current implementation&lt;/h2&gt;

&lt;p&gt;The implementation can be found on
&lt;a href=&quot;https://github.com/markus-zzz/retrocon/tree/dev&quot;&gt;github&lt;/a&gt;. While being very
much work in progress it is capable of bouncing sprites around over static
background tiles as can be seen in this animation&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/download/retrocon-sprite-bounce.apng&quot; alt=&quot;Bouncing sprites&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The PNGs for the animation above were produced by a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; based simulation using the
custom tool
&lt;a href=&quot;https://github.com/markus-zzz/retrocon/blob/dev/sim/verilator/vgamon.cpp&quot;&gt;vgamon&lt;/a&gt;
that captures the VGA output of the design either displaying it in real time
(i.e. on my machine ~8 frames per second) and optionally storing frames to PNG
files.&lt;/p&gt;

&lt;p&gt;Now Verilator is pretty awesome and this tool has already proven extremely
useful. Considering the sheer amount of simulation cycles that go into
producing a single frame makes you quickly realize that traditional simulators
such as &lt;a href=&quot;http://iverilog.icarus.com/&quot;&gt;Icarus Verilog&lt;/a&gt; don’t quite cut it for
this purpose.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Usage: ./vgamon [OPTIONS]

  --scale=N             -- set pixel scaling
  --frame-rate=N        -- try to produce a new frame every N ms
  --save-frame-from=N   -- dump frames to .png starting from frame #N
  --save-frame-to=N=N   -- dump frames to .png ending with frame #N
  --save-frame-prefix=S -- prefix dump frame files with S
  --exit-after-frame=N  -- exit after frame #N
  --trace               -- create dump.vcd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The design has been tested on a &lt;a href=&quot;https://radiona.org/ulx3s/&quot;&gt;ULX3S&lt;/a&gt; FPGA board
using the open source &lt;a href=&quot;https://symbiflow.github.io/&quot;&gt;SymbiFlow&lt;/a&gt; tools (Yosys
and nextpnr). Doing so gives a device utilization as follows for the boards
&lt;a href=&quot;https://www.latticesemi.com/Products/FPGAandCPLD/ECP5&quot;&gt;ECP5 12F&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Info: Device utilisation:
Info:          TRELLIS_SLICE:  2822/12144    23%
Info:             TRELLIS_IO:    10/  196     5%
Info:                   DCCA:     3/   56     5%
Info:                 DP16KD:    16/   56    28%
Info:             MULT18X18D:     0/   28     0%
Info:                 ALU54B:     0/   14     0%
Info:                EHXPLLL:     1/    2    50%
Info:                EXTREFB:     0/    1     0%
Info:                   DCUA:     0/    1     0%
Info:              PCSCLKDIV:     0/    2     0%
Info:                IOLOGIC:     0/  128     0%
Info:               SIOLOGIC:     8/   68    11%
Info:                    GSR:     0/    1     0%
Info:                  JTAGG:     0/    1     0%
Info:                   OSCG:     0/    1     0%
Info:                  SEDGA:     0/    1     0%
Info:                    DTR:     0/    1     0%
Info:                USRMCLK:     0/    1     0%
Info:                CLKDIVF:     0/    4     0%
Info:              ECLKSYNCB:     0/    8     0%
Info:                DLLDELD:     0/    8     0%
Info:                 DDRDLL:     0/    4     0%
Info:                DQSBUFM:     0/    8     0%
Info:        TRELLIS_ECLKBUF:     0/    8     0%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The only video output on ULX3S is a HDMI compatible connector so we borrow the
code from &lt;a href=&quot;https://github.com/daveshah1/prjtrellis-dvi&quot;&gt;Project Trellis DVI&lt;/a&gt; to
output DVI over that connector. It works surprisingly well!&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next steps&lt;/h2&gt;
&lt;p&gt;Some ideas for the future:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Implement UART based means to upload CPU code and RAM contents to running
board (having to re-synthesize as is the case now really slows down the
development cycle).&lt;/li&gt;
  &lt;li&gt;Implement horizontal flip and vertical flip sprite flags.&lt;/li&gt;
  &lt;li&gt;Support for smooth scrolling background tiles (preferably in all directions).&lt;/li&gt;
  &lt;li&gt;Look into supporting Pico-8 style sound effects.&lt;/li&gt;
  &lt;li&gt;Fix a million bugs :)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That is it for now. Hopefully I will make some more progress soon!&lt;/p&gt;</content><author><name></name></author><summary type="html">In this post we visit my latest pet project - that is building a custom 80’s style game console. Much fun ahead :)</summary></entry><entry><title type="html">A look at retro gaming hardware</title><link href="https://www.zzzconsulting.se/2019/06/26/retro-gaming-intro.html" rel="alternate" type="text/html" title="A look at retro gaming hardware" /><published>2019-06-26T00:00:00+02:00</published><updated>2019-06-26T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2019/06/26/retro-gaming-intro</id><content type="html" xml:base="https://www.zzzconsulting.se/2019/06/26/retro-gaming-intro.html">&lt;p&gt;Back when I was a kid in the late 80’s and early 90’s I had a &lt;a href=&quot;https://en.wikipedia.org/wiki/Commodore_64&quot;&gt;Commodore
64&lt;/a&gt;, a &lt;a href=&quot;https://en.wikipedia.org/wiki/Amiga_500&quot;&gt;Amiga
500&lt;/a&gt; and eventually a &lt;a href=&quot;https://en.wikipedia.org/wiki/Amiga_1200&quot;&gt;Amiga
1200&lt;/a&gt;. Now besides playing games and
calling &lt;a href=&quot;https://en.wikipedia.org/wiki/Bulletin_board_system&quot;&gt;BBS&lt;/a&gt;s I never got
around to do any programming on these devices.  Something that I quite regret
now in grown age when I realize how beautiful, and in a way simple, these
machines were. Well to be honest I did play around a bit with
&lt;a href=&quot;https://en.wikipedia.org/wiki/BASIC&quot;&gt;BASIC&lt;/a&gt; but as BASIC is well BASIC I never
really got a hang of anything and didn’t understand much either. It wasn’t
until years later when I finally learned C that things started to make sense.&lt;/p&gt;

&lt;p&gt;Not too long ago I read about the
&lt;a href=&quot;https://github.com/MiSTer-devel/Main_MiSTer/wiki&quot;&gt;MiSTer&lt;/a&gt; project and while I
have known about the &lt;a href=&quot;https://en.wikipedia.org/wiki/Minimig&quot;&gt;Minimig&lt;/a&gt; core for
a long time it wasn’t until now it appeared to be running on a almost
off-the-shelf FPGA board not requiring a hard
&lt;a href=&quot;https://en.wikipedia.org/wiki/Motorola_68000&quot;&gt;m68k&lt;/a&gt; CPU. This and seeing
Youtube videos of people reverse engineering old arcade PCBs (e.g.
&lt;a href=&quot;https://www.youtube.com/watch?v=g8gZT1F9UkE&quot;&gt;this&lt;/a&gt;) inspired me to try and do
some work in this area myself.&lt;/p&gt;

&lt;p&gt;I also found a nice little book called &lt;a href=&quot;https://www.amazon.com/dp/B07LD48CTV/ref=pe_385040_118058080_TE_M1DP&quot;&gt;Designing Video Game Hardware in
Verilog&lt;/a&gt;
by a guy named Steven Hugg. The Kindle version sells for only $12 and I highly
recommend this book, not because it contains tons of stuff you didn’t already
know or could not figure out yourself but because it is a nice read with
interesting historical remarks and it comes with a website called
&lt;a href=&quot;https://8bitworkshop.com/&quot;&gt;8bitworkshops&lt;/a&gt; that is pretty awesome.&lt;/p&gt;

&lt;p&gt;Now the website can actually be fully used without purchasing the book but I
really think it is an effort worth supporting.&lt;/p&gt;

&lt;p&gt;While the website allows you to interactively program and run old arcade
systems and consoles such as the Atari 2600 in both C and assembler what totally
blew my mind is the ability to write a custom hardware design in Verilog,
producing a VGA video signal and then having that run in the browser displaying
graphics on a simulated CRT (and with a pretty impressive frame rate too).&lt;/p&gt;

&lt;p&gt;To me that all seemed fictional, did this guy implement a complete Verilog
simulator in JavaScript that runs that fast? Well it turns out that he did not
but instead used existing software in clever ways and this post will now
briefly digress to shed some light on how.&lt;/p&gt;

&lt;p&gt;First, the source code behind the entire 8bitworkshops website is available on
Github &lt;a href=&quot;https://github.com/sehugg/8bitworkshop&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To pull off the Verilog stunt described above it uses mainly two components:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://emscripten.org/&quot;&gt;Emscripten&lt;/a&gt; - a LLVM backend that generates
JavaScript effectively allowing you to compile C++ code into JavaScript and
execute in a browser.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; - a verilog simulator
that compiles synthesizable verilog modules into C++ code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now Verilator is compiled into JavaScript by Emscripten so Verilator will run
in your browser outputting C++ code for the Verilog modules you provide. The
following question is of course what happens with this Verilator generated C++.
One option would be if Emscripten ‘Emsripted’ itself so that your browser had
the ability to turn C++ into JavaScript but that is not what is happening. The
C++ generated by Verilator only uses a subset of the full language and is quite
regular. The fact that this subset is similar, expect for some syntax details,
to JavaScript is taken advantage of to to simply do a regexp based translation.&lt;/p&gt;

&lt;p&gt;Verilated C++ is translated into JavaScript by
&lt;a href=&quot;https://github.com/sehugg/8bitworkshop/blob/10f89d0c53e610934b0035bbed5a4af258844786/src/worker/verilator2js.ts&quot;&gt;src/worker/verilator2js.ts&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If one studies an example of how to use Verilator natively in C++ then one can
see that pattern being hand translated to JS in
&lt;a href=&quot;https://github.com/sehugg/8bitworkshop/blob/10f89d0c53e610934b0035bbed5a4af258844786/src/platform/verilog.ts&quot;&gt;src/platform/verilog.ts&lt;/a&gt;.
Especially the function
&lt;a href=&quot;https://github.com/sehugg/8bitworkshop/blob/10f89d0c53e610934b0035bbed5a4af258844786/src/platform/verilog.ts#L496-L539&quot;&gt;updateVideoFrameCycles&lt;/a&gt;
calls vidtick (calling tick2 to toggle the clock and advance simulation) and
extracting VGA signals from the model, storing to a JS frame buffer for display
on the web page.&lt;/p&gt;

&lt;p&gt;That concludes this post. Hopefully it will mark the start of a new series
diving into the details of designing some old school video game hardware.&lt;/p&gt;</content><author><name></name></author><summary type="html">Back when I was a kid in the late 80’s and early 90’s I had a Commodore 64, a Amiga 500 and eventually a Amiga 1200. Now besides playing games and calling BBSs I never got around to do any programming on these devices. Something that I quite regret now in grown age when I realize how beautiful, and in a way simple, these machines were. Well to be honest I did play around a bit with BASIC but as BASIC is well BASIC I never really got a hang of anything and didn’t understand much either. It wasn’t until years later when I finally learned C that things started to make sense.</summary></entry><entry><title type="html">Building a modem - part 2</title><link href="https://www.zzzconsulting.se/2018/08/11/build-a-modem-part-2.html" rel="alternate" type="text/html" title="Building a modem - part 2" /><published>2018-08-11T00:00:00+02:00</published><updated>2018-08-11T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/08/11/build-a-modem-part-2</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/08/11/build-a-modem-part-2.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In this post we return to our modem building project to checkup on the
progress.&lt;/p&gt;

&lt;p&gt;The code corresponding to the progress of this post is available as branch
&lt;a href=&quot;https://github.com/markus-zzz/modem/tree/part-2&quot;&gt;part-2&lt;/a&gt; of the modem GitHub
repository.&lt;/p&gt;

&lt;h3 id=&quot;hardware-blocks&quot;&gt;Hardware blocks&lt;/h3&gt;
&lt;p&gt;The current implementation exposes two AXI mapped ring buffers, and some
control register, using the address map from the &lt;a href=&quot;/2018/08/03/build-a-modem-part-1.html&quot;&gt;previous
post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Each ring buffer is currently implemented using a dual ported synchronous SRAM
block with one port being tied to the AXI and the other to the internal data
path of the modem.&lt;/p&gt;

&lt;p&gt;Now dual ported memories are large and expensive and for the modest data rates
we plan to put on these memories we can certainly get a way both AXI and
internal data path sharing the single port on a single ported memory. Doing so
is of course not free and it will be at the expense of some increased
implementation complexity but that we can handle later. So in other words, for
now dual ported is good since they allow for slightly simpler implementation
but we should eventually switch to using single ported.&lt;/p&gt;

&lt;p&gt;Either way, dual ported or not, Synchronous SRAM blocks have one slightly
annoying property with respect to reads and that is that the read address is
clocked. That is the behavioural model looks like this&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // read operation
    always @(posedge rclk) begin
        if (rce) begin
            ra &amp;lt;= raddr;
        end
    end

    assign do = mem[ra];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In other words you cannot simply present the read address (&lt;em&gt;raddr&lt;/em&gt;) and expect
to latch the data (&lt;em&gt;do&lt;/em&gt;) at the next rising clock edge but instead you have to
wait an additional cycle. Of course it is all pretty obvious when you think
about it (they are called synchronous for a reason) but I for one tend to
forget this ever so often.&lt;/p&gt;

&lt;p&gt;One place where this shows up is in the AXI read channel response logic in
&lt;a href=&quot;https://github.com/markus-zzz/modem/blob/part-2/rtl/verilog/modem_axi_slave.v&quot;&gt;rtl/verilog/modem_axi_slave.v&lt;/a&gt;
since we have to delay the read response for ring buffer reads by one cycle
compared to if it was a register read.&lt;/p&gt;

&lt;p&gt;Another thing that slightly complicates matters is that we cannot simply drain
the TX ring buffer at constant full speed but instead need to repeatedly do
stop and go to avoid overflowing the internal data path as it operates at a
much lower speed (one byte is several symbols, one symbol is several samples,
etc, etc).&lt;/p&gt;

&lt;p&gt;To deal with this we need a &lt;em&gt;handshake&lt;/em&gt; mechanism, and we have chosen to do one
using two signals, &lt;em&gt;valid&lt;/em&gt; and &lt;em&gt;ready&lt;/em&gt;, as follows.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Producer asserts &lt;em&gt;valid&lt;/em&gt; when valid data is output&lt;/li&gt;
  &lt;li&gt;Consumer asserts &lt;em&gt;ready&lt;/em&gt; when it can accept data&lt;/li&gt;
  &lt;li&gt;The transaction occurs on a rising clock edge when both &lt;em&gt;ready&lt;/em&gt; and &lt;em&gt;valid&lt;/em&gt;
are sampled high&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Right now the TX and RX ring buffers are tied together in loop-back mode with
the silly action of transforming lower-case letters to upper-case and vice
versa.&lt;/p&gt;

&lt;p&gt;An interrupt pulse is generated when the hardware updates the read pointer of
the TX ring and the write pointer of the RX ring.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://github.com/markus-zzz/modem/blob/part-2/rtl/verilog/modem_axi_top.v&quot;&gt;rtl/verilog/modem_axi_top.v&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;tx-ctrl&quot;&gt;TX-Ctrl&lt;/h4&gt;
&lt;p&gt;This is the controller for the transmit ring buffer. It is basically a state
machine that sits around waiting for the read pointer to be become unequal the
write pointer (indicating that the buffer is no longer empty) and then starts
reading words.&lt;/p&gt;

&lt;p&gt;The fact that the internal data path needs to be fed with bytes, the pipelined
read behaviour of the memory and the presence of flow control slightly
complicates things. This in combination with the long term ambition to switch
to a single ported memory results in the current simple design, with perhaps a
seemingly abundant number of states.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://github.com/markus-zzz/modem/blob/part-2/rtl/verilog/tx_ctrl.v&quot;&gt;rtl/verilog/tx_ctrl.v&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;rx-ctrl&quot;&gt;RX-Ctrl&lt;/h4&gt;
&lt;p&gt;This is the controller for the receive ring buffer. It is quite similar to its
transmit counterpart although it operates in the opposite direction and as a
result does not have to deal with the issues of memory reads.&lt;/p&gt;

&lt;p&gt;One thing we do have to deal with here however is the detection of overflows,
but that is rather straight forward and we simply skip writing the message
header and advancing the write pointer when this condition is detected.
Eventually we should set a status bit indicating the overflow in the header of
the next message written to the ring and have the device driver informing
user-space somehow (perhaps by one &lt;em&gt;read&lt;/em&gt; returning &lt;em&gt;EOVERFLOW&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://github.com/markus-zzz/modem/blob/part-2/rtl/verilog/rx_ctrl.v&quot;&gt;rtl/verilog/rx_ctrl.v&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;linux-device-driver&quot;&gt;Linux device driver&lt;/h3&gt;
&lt;p&gt;The current device driver resembles the one from the I2C series quite a lot. A
&lt;em&gt;read&lt;/em&gt; operation will block if the RX ring is empty and a &lt;em&gt;write&lt;/em&gt; operation
will block if the TX ring has insufficient space left for the message. In
either case the sleeping process will be awoken by previously mentioned
interrupt pulse (indicating that the HW has updated its pointers).&lt;/p&gt;

&lt;p&gt;This implementation seems to work for now but later on should probably add
mutexes to protect the ring buffers from concurrent access (i.e. many processes
doing &lt;em&gt;read&lt;/em&gt; at the same time and similarly for &lt;em&gt;write&lt;/em&gt;). Not sure if that
use-case make a ton of sense though but we should properly handle that
situation anyway.&lt;/p&gt;

&lt;p&gt;Also we would likely benefit from a more fine grained interrupt control, being
able to see if the source was RX or TX and being able to mask.&lt;/p&gt;

&lt;p&gt;For details see
&lt;a href=&quot;https://github.com/markus-zzz/modem/blob/part-2/linux/zzz-modem-driver.c&quot;&gt;linux/zzz-modem-driver.c&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;try-it-out&quot;&gt;Try it out!&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/markus-zzz/modem.git
cd modem
git checkout part-2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;As a sanity check run the simple standalone test transmitting a sequence of
test messages from size 4 to size 16&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./build-all.sh &amp;amp;&amp;amp; ./run-all.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;After that we can move on to do testing with QEMU and the Linux device driver.
The steps for setting this up are almost identical to what was described in the
I2C controller series (especially &lt;a href=&quot;/2018/07/18/i2c-controller-part-2.html&quot;&gt;part-2&lt;/a&gt; and &lt;a href=&quot;/2018/07/27/i2c-controller-part-4.html&quot;&gt;part-4&lt;/a&gt;) so repetion here will be brief.&lt;/p&gt;

&lt;p&gt;Modify the Linux device tree for our modem device&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/arch/arm/boot/dts/vexpress-v2m.dtsi b/arch/arm/boot/dts/vexpress-v2m.dtsi
index b0021a8..2279196 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/arch/arm/boot/dts/vexpress-v2m.dtsi
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/arch/arm/boot/dts/vexpress-v2m.dtsi
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -179,8 +179,8 @@&lt;/span&gt;
                                clock-names = &quot;uartclk&quot;, &quot;apb_pclk&quot;;
                        };

-                       v2m_serial3: uart@c000 {
&lt;span class=&quot;gd&quot;&gt;-                               compatible = &quot;arm,pl011&quot;, &quot;arm,primecell&quot;;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+                       zzz_modem: zzz_modem@c000 {
+                               compatible = &quot;zzz-modem&quot;;
&lt;/span&gt;                                reg = &amp;lt;0x0c000 0x1000&amp;gt;;
                                interrupts = &amp;lt;8&amp;gt;;
                                clocks = &amp;lt;&amp;amp;v2m_oscclk2&amp;gt;, &amp;lt;&amp;amp;smbclk&amp;gt;;
&lt;span class=&quot;gh&quot;&gt;diff --git a/arch/arm/boot/dts/vexpress-v2p-ca9.dts b/arch/arm/boot/dts/vexpress-v2p-ca9.dts
index 5814460..98206c0 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/arch/arm/boot/dts/vexpress-v2p-ca9.dts
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/arch/arm/boot/dts/vexpress-v2p-ca9.dts
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -25,7 +25,6 @@&lt;/span&gt;
                serial0 = &amp;amp;v2m_serial0;
                serial1 = &amp;amp;v2m_serial1;
                serial2 = &amp;amp;v2m_serial2;
&lt;span class=&quot;gd&quot;&gt;-               serial3 = &amp;amp;v2m_serial3;
&lt;/span&gt;                i2c0 = &amp;amp;v2m_i2c_dvi;
                i2c1 = &amp;amp;v2m_i2c_pcie;
        };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;For QEMU we need to be using
&lt;a href=&quot;https://github.com/markus-zzz/modem/blob/part-2/qemu/axi_master_client_device.c&quot;&gt;qemu/axi_master_client_device.c&lt;/a&gt;
and not the corresponding file from the previous repository.&lt;/p&gt;

&lt;p&gt;Once everything is built and moved to the proper places the RTL simulation is
started with&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vvp -M. -mvpi_axi_master modem.vvp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and QEMU as before. Watch Linux boot, then login, install the module and do the
following&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat /dev/zzz-modem &amp;gt; rx.txt &amp;amp;
echo &quot;Hello World!&quot; &amp;gt; /dev/zzz-modem
cat rx.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And to transmit some more messages of varying length&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for i in $(seq 100); do echo &quot;Hello $(seq -s &quot; &quot; $i)&quot; &amp;gt; /dev/zzz-modem; done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;what-is-next&quot;&gt;What is next?&lt;/h3&gt;

&lt;p&gt;Right now we have implemented the loop-back at the highest level possible, i.e.
right after the ring buffers. This is nice, in my opinion, since it allows for
easy testing with the &lt;em&gt;/dev/zzz-modem&lt;/em&gt; device node right away and gives us more
time to flush out any annoying bugs in the HW/SW interface.&lt;/p&gt;

&lt;p&gt;Since our implementation strategy is to go top down we will continue to do so
and keep on moving the loop-back loop further down the stack as more layers are
added.&lt;/p&gt;

&lt;p&gt;Currently I imagine that the following milestones will be useful&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Next have loop-back of IQ symbols&lt;/li&gt;
  &lt;li&gt;Then loop-back of sampled pulse shaped IQ symbols&lt;/li&gt;
  &lt;li&gt;Then introduce a shift so that we need to do synchronization in RX&lt;/li&gt;
  &lt;li&gt;Do the same thing as previous step but use passband instead of baseband&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;Finally, a physical audio loop-back wire on the ZedBoard&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That is it for this post. Questions or feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction In this post we return to our modem building project to checkup on the progress.</summary></entry><entry><title type="html">MyCC - an introduction</title><link href="https://www.zzzconsulting.se/2018/08/04/mycc-an-introduction.html" rel="alternate" type="text/html" title="MyCC - an introduction" /><published>2018-08-04T00:00:00+02:00</published><updated>2018-08-04T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/08/04/mycc-an-introduction</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/08/04/mycc-an-introduction.html">&lt;p&gt;Today we will be looking at a prototype toy C compiler that I have been working
on every now and then for a while. Of course it is nowhere near complete nor
even useful for any particular purpose at all besides perhaps my own amusement
and possibly that of others.&lt;/p&gt;

&lt;p&gt;Still I think that it serves as a meaningful exercise to start from a clean
slate every now and then and do things the way that you feel are right (which
may be the simplest or most naive way possible) and not being burdened by any
particular framework.&lt;/p&gt;

&lt;p&gt;Say for instance that you read this really interesting article about
implementing a SSA based register allocator and now you want to try it out. So
you turn to a well established compiler framework like LLVM or GCC. Okay, so
the code base is huge and the compiler build time is insane and you just wanted
to play around a bit. Clearly that situation is not ideal and at these times a
much much simpler and smaller framework would be useful. Preferably one that
still preserves some of the good ideas from the larger ones.&lt;/p&gt;

&lt;p&gt;Now I do not want to bash on big compiler frameworks (looking your way LLVM)
but the fact remains that these huge frameworks are not suitable for every
possible purpose and depending on what your intended purpose is they may in
fact make things a lot more complicated than they need to be.&lt;/p&gt;

&lt;h2 id=&quot;mycc&quot;&gt;MyCC&lt;/h2&gt;

&lt;p&gt;The design of MyCC borrows heavily from LLVM. One of the best things about LLVM
is the use of a very well defined intermediate representation in the middle
end. This LLVM IR is linearised and resembles assembly language so much that
they in fact call it &lt;a href=&quot;https://llvm.org/docs/LangRef.html&quot;&gt;the LLVM Assembly
Language&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As stated in that document one of the design criteria for the LLVM IR was to
represents well both in graph form in compiler memory as well as in human
readable textual form in dump files. The importance of the latter cannot be
overstated.&lt;/p&gt;

&lt;p&gt;While a well defined IR allows us to import and export the entire compilation
state between passes it also allows us to create a virtual machine that can
execute this IR. Together these two provide for the development of some very
powerful testing tool.&lt;/p&gt;

&lt;h2 id=&quot;preparations&quot;&gt;Preparations&lt;/h2&gt;
&lt;p&gt;To acquire the code base and build the compiler follow these steps. Note that
the compiler build time for a full debug build is just a second or two (which
is hardly surprising since there is so little code and it is not C++).&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ZZZ_ROOT=some/path
cd $ZZZ_ROOT
git clone https://github.com/markus-zzz/mycc.git
mkdir $ZZZ_ROOT/mycc/build
cd $ZZZ_ROOT/mycc/build
make -f $ZZZ_ROOT/mycc/src/Makefile -j8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Next we run the test suite by executing the following commands.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT/mycc/test
./runner.pl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now what just happened here is actually quite interesting so let’s look into
that. If we enforce the convention that each of our tests shall return a 32 bit
integer as its result (and preferably not just &lt;em&gt;true&lt;/em&gt;/&lt;em&gt;false&lt;/em&gt; as that would
increase the risk of falsely indicating that a test passes due to a miscompile)
we can do the following.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Use a reference compiler (e.g. gcc) to produce a known good value&lt;/li&gt;
  &lt;li&gt;Use the IR simulator to verify that the IR simulates to the same good value
after each pass&lt;/li&gt;
  &lt;li&gt;Verify that the final executable produces the good value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course this testing is not immune to all kind of problems but I would argue
that it provides a pretty good coverage for rather little effort once you have
the basic machinery in place. To add a new test, simply add a well defined C
code snippet that produces an integer as result.&lt;/p&gt;

&lt;h2 id=&quot;a-tour-down-the-compilation-pipeline&quot;&gt;A tour down the compilation pipeline&lt;/h2&gt;
&lt;p&gt;Let us take a look at a simple example and see how the code gets transformed as
we move further down the compilation pipeline. Consider something simple such
as &lt;em&gt;dot.c&lt;/em&gt; given below&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int dot(int *a, int *b, int len)
{
	int i;
	int sum = 0;
	for (i = 0; i &amp;lt; len; i = i + 1) {
		sum = sum + a[i] * b[i];
	}

	return sum;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Begin by invoking the compiler driver as in&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./build/driver --dump-all dot.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;doing so should produce a set of dump files where the intermediate
representation at the given stage is dumped. These files are very important for
debugging since they often times allow you to pinpoint at what stage things go
wrong&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zzzconsulting.se/download/mycc-an-introduction/ast_00_pristine.txt&quot;&gt;ast_00_pristine.txt&lt;/a&gt; -
When the front end parses the input code it produces an Abstract Syntax Tree
(AST). This representation is extremely verbose and essentially contains an AST
node for each grammar rule applied.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zzzconsulting.se/download/mycc-an-introduction/ir_00_pristine.txt&quot;&gt;ir_00_pristine.txt&lt;/a&gt; -
Middle end Intermediate Representation (what we simply call IR) immediately
after being translated from AST.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zzzconsulting.se/download/mycc-an-introduction/ir_01_mem2reg.txt&quot;&gt;ir_01_mem2reg.txt&lt;/a&gt; -
IR after applying the &lt;em&gt;mem2reg&lt;/em&gt; optimization pass.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zzzconsulting.se/download/mycc-an-introduction/cg_00_iselect.txt&quot;&gt;cg_00_iselect.txt&lt;/a&gt; -
Code Generator intermediate representation after selecting machine instructions
for the middle end IR. Note that this IR is using virtual registers and is
still in SSA form.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zzzconsulting.se/download/mycc-an-introduction/cg_01_regalloc.txt&quot;&gt;cg_01_regalloc.txt&lt;/a&gt; -
Machine instructions after allocating physical registers.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zzzconsulting.se/download/mycc-an-introduction/cg_02_branch_predication.txt&quot;&gt;cg_02_branch_predication.txt&lt;/a&gt; -
Machine instructions after performing branch predication optimization pass.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h2&gt;
&lt;p&gt;That is it for this post. When we return to MyCC in a later post I intend to
write about the implementation of its SSA based register allocator.&lt;/p&gt;</content><author><name></name></author><summary type="html">Today we will be looking at a prototype toy C compiler that I have been working on every now and then for a while. Of course it is nowhere near complete nor even useful for any particular purpose at all besides perhaps my own amusement and possibly that of others.</summary></entry><entry><title type="html">Building a modem - part 1</title><link href="https://www.zzzconsulting.se/2018/08/03/build-a-modem-part-1.html" rel="alternate" type="text/html" title="Building a modem - part 1" /><published>2018-08-03T00:00:00+02:00</published><updated>2018-08-03T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/08/03/build-a-modem-part-1</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/08/03/build-a-modem-part-1.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;This is the first post of a new series where we are going to attempt the build
a simple modem. In other words we will try to build a digital communications
link where the sender modulates a communication message, a stream of bytes, to
make it suitable for transmission over a given media and the receiver
demodulates to recover the original message.&lt;/p&gt;

&lt;p&gt;Since your author is no expert (to put it mildly) in the fields of
&lt;em&gt;communications theory&lt;/em&gt; or &lt;em&gt;signal processing&lt;/em&gt; this post series will not focus
on the theoretical details of that but instead refer to the excellent
presentation of those matters over at &lt;a href=&quot;http://dspillustrations.com&quot;&gt;DSP
Illustrations&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I envision the complete system to run on a &lt;a href=&quot;http://zedboard.org/&quot;&gt;ZedBoard&lt;/a&gt; (or
actually two to make it more interesting) and use the onboard audio codec (i.e.
sound waves in the range 20Hz-20kHz) as the transmission media. However the
actual hardware is not really important to follow along as we will rely
extensively on a QEMU / RTL simulation environment.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;p&gt;Let’s begin by presenting an overview.&lt;/p&gt;

&lt;h3 id=&quot;linux-device-driver&quot;&gt;Linux device driver&lt;/h3&gt;
&lt;p&gt;A Linux device driver presents the device node &lt;em&gt;/dev/zzzmodem&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;write&lt;/em&gt; - queues a message for transmission. A single call to &lt;em&gt;write&lt;/em&gt; results
in a single message queued.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;read&lt;/em&gt; - returns a received message. A call to &lt;em&gt;read&lt;/em&gt; returns a single
received message (i.e. the buffer size given must be equal to the maximal
transmission unit (MTU)).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since the &lt;em&gt;read&lt;/em&gt;/&lt;em&gt;write&lt;/em&gt; interface is based on complete messages the driver
should allow for multiple processes to &lt;em&gt;read&lt;/em&gt; and &lt;em&gt;write&lt;/em&gt; at the same time.&lt;/p&gt;

&lt;h3 id=&quot;modem-block-memory-mapped-interface&quot;&gt;Modem block memory mapped interface&lt;/h3&gt;
&lt;p&gt;The modem block exposes two ring buffers in its address map. One for
transmitting (TX) and one for receiving (RX), each of them are accompanied with
read and write pointers.&lt;/p&gt;

&lt;p&gt;For TX a device driver &lt;em&gt;write&lt;/em&gt; will result in one full message being put in
the TX ring buffer. If there is no room then the driver will put the writing
process to sleep. The read pointer updates in one go as the entire message is
sent. An interrupt can be generated whenever the read pointer updates.&lt;/p&gt;

&lt;p&gt;For RX a device driver &lt;em&gt;read&lt;/em&gt; will result in one full message being lifted from
the RX ring buffer. If there are no message to lift then the calling process
will be put to sleep. An interrupt can be generated when the write pointer
updates. The write pointer will only be updated when a full message is put in
the buffer. If the buffer overruns a counter will be incremented and possibly
interrupt generated.&lt;/p&gt;

&lt;p&gt;Everything is 32 bit aligned inside the ring buffers. A message begins with a
32 bit header indicating the length of the message. The next message in the
ring buffer will begin (i.e. have its header) at this offset but aligned to a
32 bit boundary.&lt;/p&gt;

&lt;p&gt;The following suggested address map of our modem device provides the essentials
and fits well in 4KiB (i.e. 0x1000 bytes).&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Begin&lt;/th&gt;
      &lt;th&gt;End&lt;/th&gt;
      &lt;th&gt;Access&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0x000&lt;/td&gt;
      &lt;td&gt;0x3ff&lt;/td&gt;
      &lt;td&gt;W&lt;/td&gt;
      &lt;td&gt;TX ring buffer (1 KiB)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x400&lt;/td&gt;
      &lt;td&gt;0x7ff&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;RX ring buffer (1 KiB)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x800&lt;/td&gt;
      &lt;td&gt;0x803&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;TX read pointer&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x804&lt;/td&gt;
      &lt;td&gt;0x807&lt;/td&gt;
      &lt;td&gt;R/W&lt;/td&gt;
      &lt;td&gt;TX write pointer&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x808&lt;/td&gt;
      &lt;td&gt;0x80b&lt;/td&gt;
      &lt;td&gt;R/W&lt;/td&gt;
      &lt;td&gt;RX read pointer&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x80c&lt;/td&gt;
      &lt;td&gt;0x80f&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;RX write pointer&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Access permissions are what one would expect, that is software cannot write to
registers/memory owned by the modem block. All registers should be readable by
software though to ease debugging. Writes to a read-only address are simply
ignored.&lt;/p&gt;

&lt;h3 id=&quot;signal-processing&quot;&gt;Signal processing&lt;/h3&gt;
&lt;p&gt;The modulation of choice for our modem will be Quadrature Phase Shift Keying
(QPSK), meaning that each &lt;em&gt;symbol&lt;/em&gt; will convey two data bits. A &lt;em&gt;symbol mapper&lt;/em&gt;
will take care of the straight forward task of turning our byte stream message
into a stream of QPSK symbols. For these symbols we then intend to apply the
signal processing chain described
&lt;a href=&quot;http://dspillustrations.com/pages/posts/misc/baseband-up-and-downconversion-and-iq-modulation.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Of course a lot more needs to be said about that and we will constantly return
to this topic as needed. For now though, for the purpose of an overview, this
should be enough.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;
&lt;p&gt;As there is certainly no shortage of work to be done for this project how do we
decide what to do first?&lt;/p&gt;

&lt;p&gt;Well, let us approach this from the top down so I say let’s begin with the ring
buffers and their software interface.&lt;/p&gt;

&lt;p&gt;To quickly have something that is testable we can set our first goal as
follows: Implement RX and TX ring buffers and tie them together in loop back
mode with some silly action like transforming lowercase letters to uppercase.&lt;/p&gt;

&lt;p&gt;Having those parts in place early will hopefully allow us to develop a more
sophisticated testing framework that will come in handy later on when we
approach the more mathematical areas further down the pipe. As well as giving
us additional mileage on our perhaps mundane but oh so error prone byte
shoveling machinery.&lt;/p&gt;

&lt;p&gt;That’s it for this post! When we return in the next post we will look into the
details of implementing the ‘byte shoveling machinery’.&lt;/p&gt;

&lt;p&gt;Until then, as usual, if there are questions or feedback - leave a comment
below!&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction This is the first post of a new series where we are going to attempt the build a simple modem. In other words we will try to build a digital communications link where the sender modulates a communication message, a stream of bytes, to make it suitable for transmission over a given media and the receiver demodulates to recover the original message.</summary></entry><entry><title type="html">A basic I2C controller - part 4</title><link href="https://www.zzzconsulting.se/2018/07/27/i2c-controller-part-4.html" rel="alternate" type="text/html" title="A basic I2C controller - part 4" /><published>2018-07-27T00:00:00+02:00</published><updated>2018-07-27T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/07/27/i2c-controller-part-4</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/07/27/i2c-controller-part-4.html">&lt;p&gt;Now we are going to revisit the device driver from part 3 of this series and
redo it properly.&lt;/p&gt;

&lt;p&gt;Modern Linux uses something called a &lt;em&gt;device tree&lt;/em&gt; to describe the
configuration of a SoC and as the name suggests this data structure describes
what devices are connected to a system. Among the properties described the
following interest us at this point&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;identifier for a compatible device driver&lt;/li&gt;
  &lt;li&gt;where is this device mapped in memory&lt;/li&gt;
  &lt;li&gt;what interrupt line is this device connected to&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;preparations&quot;&gt;Preparations&lt;/h2&gt;
&lt;p&gt;Since we have chosen to use the ARM VersatileExpress platform for our
experiments we are going to have to modify its &lt;em&gt;device tree&lt;/em&gt; description which
is contained in the files &lt;em&gt;arch/arm/boot/dts/vexpress-v2p-ca9.dts&lt;/em&gt; and
&lt;em&gt;arch/arm/boot/dts/vexpress-v2m.dtsi&lt;/em&gt; (where the former includes the latter).
In fact the former describes the CPU and the latter describes the &lt;em&gt;motherboard&lt;/em&gt;
i.e. the board that contains all the peripherals.&lt;/p&gt;

&lt;p&gt;Since I do not poses a detailed knowledge about this system, for matter such as
what memory regions are available or what interrupt lines are available, the
easiest way forward is going to be to hijack an existing device and reuse its
resources (memory range and interrupt line). Luckily the motherboard has four
UARTs and for our purposes only the first one is needed, so we can safely
borrow the resources from the last one.&lt;/p&gt;

&lt;p&gt;In practise that means that we need to make the following modifications&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/arch/arm/boot/dts/vexpress-v2m.dtsi b/arch/arm/boot/dts/vexpress-v2m.dtsi
index b0021a8..f651956 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/arch/arm/boot/dts/vexpress-v2m.dtsi
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/arch/arm/boot/dts/vexpress-v2m.dtsi
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -179,8 +179,8 @@&lt;/span&gt;
                                clock-names = &quot;uartclk&quot;, &quot;apb_pclk&quot;;
                        };

-                       v2m_serial3: uart@c000 {
&lt;span class=&quot;gd&quot;&gt;-                               compatible = &quot;arm,pl011&quot;, &quot;arm,primecell&quot;;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+                       zzz_i2c_eprom: zzz_i2c_eprom@c000 {
+                               compatible = &quot;zzz-i2c-eprom&quot;;
&lt;/span&gt;                                reg = &amp;lt;0x0c000 0x1000&amp;gt;;
                                interrupts = &amp;lt;8&amp;gt;;
                                clocks = &amp;lt;&amp;amp;v2m_oscclk2&amp;gt;, &amp;lt;&amp;amp;smbclk&amp;gt;;
&lt;span class=&quot;gh&quot;&gt;diff --git a/arch/arm/boot/dts/vexpress-v2p-ca9.dts b/arch/arm/boot/dts/vexpress-v2p-ca9.dts
index 5814460..98206c0 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/arch/arm/boot/dts/vexpress-v2p-ca9.dts
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/arch/arm/boot/dts/vexpress-v2p-ca9.dts
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -25,7 +25,6 @@&lt;/span&gt;
                serial0 = &amp;amp;v2m_serial0;
                serial1 = &amp;amp;v2m_serial1;
                serial2 = &amp;amp;v2m_serial2;
&lt;span class=&quot;gd&quot;&gt;-               serial3 = &amp;amp;v2m_serial3;
&lt;/span&gt;                i2c0 = &amp;amp;v2m_i2c_dvi;
                i2c1 = &amp;amp;v2m_i2c_pcie;
        };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;At this point we can (and should) build Linux and boot to note that it finds
one serial port less. Next let’s turn our attention to QEMU where we apply the
following change&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/hw/arm/vexpress.c b/hw/arm/vexpress.c
index 9fad791..c1f7550 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/hw/arm/vexpress.c
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/hw/arm/vexpress.c
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -625,7 +625,11 @@&lt;/span&gt; static void vexpress_common_init(MachineState *machine)
     pl011_create(map[VE_UART0], pic[5], serial_hds[0]);
     pl011_create(map[VE_UART1], pic[6], serial_hds[1]);
     pl011_create(map[VE_UART2], pic[7], serial_hds[2]);
&lt;span class=&quot;gi&quot;&gt;+#if 0
&lt;/span&gt;     pl011_create(map[VE_UART3], pic[8], serial_hds[3]);
&lt;span class=&quot;gi&quot;&gt;+#else
&lt;/span&gt;     sysbus_create_simple(&quot;axi_master_client_device&quot;, map[VE_UART3], pic[8]);
&lt;span class=&quot;gi&quot;&gt;+#endif
&lt;/span&gt;
     sysbus_create_simple(&quot;sp804&quot;, map[VE_TIMER01], pic[2]);
     sysbus_create_simple(&quot;sp804&quot;, map[VE_TIMER23], pic[3]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;i.e. we map our device to the same address and interrupt as where the fourth
UART used to be.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;
&lt;p&gt;In RTL the I2C controller has been extended with an IRQ line that asserts
whenever the controller state machine goes from a non-idle state to idle (i.e.
it has just finished work). An AXI mapped register has also been added that,
when written to, de-asserts the IRQ line.&lt;/p&gt;

&lt;p&gt;Since our RTL simulation is not that tightly tied into QEMU (and there is some
delay between a de-assert write and the de-asserted IRQ line finds its way back
into QEMU) we are going to use the IRQ line as &lt;em&gt;edge triggered&lt;/em&gt; to avoid
problems with the ISR falsely triggering.&lt;/p&gt;

&lt;p&gt;After rebuilding QEMU and Linux (as described in previous posts) we can now
focus our attention on the actual device driver
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/linux/i2c-eprom-driver-irq.c&quot;&gt;linux/i2c-eprom-driver-irq.c&lt;/a&gt;.
I would say that it differs from the previous attempt in the following ways&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Registers as a &lt;em&gt;platform driver&lt;/em&gt; and as such only gets called for &lt;em&gt;device
tree&lt;/em&gt; entries that match the given compatibility string&lt;/li&gt;
  &lt;li&gt;Gets the interrupt number and mapped memory range from the &lt;em&gt;device tree&lt;/em&gt; (see
probe function)&lt;/li&gt;
  &lt;li&gt;State machine inside interrupt handler&lt;/li&gt;
  &lt;li&gt;Wait queues to block user process while waiting for a file operation to
finish&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;During operation the &lt;em&gt;dev_read&lt;/em&gt;/&lt;em&gt;dev_write&lt;/em&gt; function does the first register
write to the I2C controller and then puts itself on a wait queue. The state
machine in the ISR will do the remaining register writes to the controller one
at a time. When the last operation has finished the ISR wakes up the sleeping
process.&lt;/p&gt;

&lt;p&gt;The wait queue handling deserves some further explanation as to why we cannot
use the more convenient &lt;em&gt;wait_event_interruptible&lt;/em&gt; and instead have to expanded
the sequence as follows.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prepare_to_wait(&amp;amp;wq, &amp;amp;wait, TASK_INTERRUPTIBLE);
/* I2C address device for write mode */
state = S_WRITE_1;
axi_master_write(i2c_ctrl_addr, i2c_ctrl_we_bit | i2c_ctrl_start_bit | I2C_ADDR &amp;lt;&amp;lt; 1 | 0 &amp;lt;&amp;lt; 0);
schedule();
finish_wait(&amp;amp;wq, &amp;amp;wait);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The reason for this is that we need to write the controller command (that will
eventually generate the interrupt so that our ISR wakes us up) before we go to
sleep. However if we for some reason got delayed at the point after the
controller write but before entering our sleep we could have a situation where
the ISR signals us to wake up before we have gone to sleep and then, when we
actually do go to sleep, there will be no ISR to wake us up.&lt;/p&gt;

&lt;p&gt;To deal with this situation it is a common pattern to mark ourselves as
sleeping with the &lt;em&gt;prepare_to_wait&lt;/em&gt; call, then do the controller write and
finally yield with a call to &lt;em&gt;schedule&lt;/em&gt;. This way there is no harm if the ISR
wakes us up before yielding.&lt;/p&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h2&gt;
&lt;p&gt;Now there are certainly more improvements that could be made to the driver and
especially in the area of concurrent access to the device but I think that we
are going to be happy with the current state for this post. To be honest the
driver for this device feels a bit contrived and I would rather revisit this
topic with a more realistic device (e.g. some sort of communications device
with ring buffers for rx and tx).&lt;/p&gt;

&lt;p&gt;Did you like this post? Questions or feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">Now we are going to revisit the device driver from part 3 of this series and redo it properly.</summary></entry></feed>