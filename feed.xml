<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="https://www.zzzconsulting.se/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.zzzconsulting.se/" rel="alternate" type="text/html" /><updated>2018-07-27T09:56:51+02:00</updated><id>https://www.zzzconsulting.se/</id><title type="html">ZZZ-Consulting</title><subtitle>Consulting services offered in the fields of Compiler engineering, Graphics programming and Embedded computing.</subtitle><entry><title type="html">A basic I2C controller - part 4</title><link href="https://www.zzzconsulting.se/2018/07/27/i2c-controller-part-4.html" rel="alternate" type="text/html" title="A basic I2C controller - part 4" /><published>2018-07-27T00:00:00+02:00</published><updated>2018-07-27T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/07/27/i2c-controller-part-4</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/07/27/i2c-controller-part-4.html">&lt;p&gt;Now we are going to revisit the device driver from part 3 of this series and
redo it properly.&lt;/p&gt;

&lt;p&gt;Modern Linux uses something called a &lt;em&gt;device tree&lt;/em&gt; to describe the
configuration of a SoC and as the name suggests this data structure describes
what devices are connected to a system. Among the properties described the
following interest us at this point&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;identifier for a compatible device driver&lt;/li&gt;
  &lt;li&gt;where is this device mapped in memory&lt;/li&gt;
  &lt;li&gt;what interrupt line is this device connected to&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;preparations&quot;&gt;Preparations&lt;/h2&gt;
&lt;p&gt;Since we have chosen to use the ARM VersatileExpress platform for our
experiments we are going to have to modify its &lt;em&gt;device tree&lt;/em&gt; description which
is contained in the files &lt;em&gt;arch/arm/boot/dts/vexpress-v2p-ca9.dts&lt;/em&gt; and
&lt;em&gt;arch/arm/boot/dts/vexpress-v2m.dtsi&lt;/em&gt; (where the former includes the latter).
In fact the former describes the CPU and the latter describes the &lt;em&gt;motherboard&lt;/em&gt;
i.e. the board that contains all the peripherals.&lt;/p&gt;

&lt;p&gt;Since I do not poses a detailed knowledge about this system, for matter such as
what memory regions are available or what interrupt lines are available, the
easiest way forward is going to be to hijack an existing device and reuse its
resources (memory range and interrupt line). Luckily the motherboard has four
UARTs and for our purposes only the first one is needed, so we can safely
borrow the resources from the last one.&lt;/p&gt;

&lt;p&gt;In practise that means that we need to make the following modifications&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/arch/arm/boot/dts/vexpress-v2m.dtsi b/arch/arm/boot/dts/vexpress-v2m.dtsi
index b0021a8..f651956 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/arch/arm/boot/dts/vexpress-v2m.dtsi
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/arch/arm/boot/dts/vexpress-v2m.dtsi
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -179,8 +179,8 @@
&lt;/span&gt;                                clock-names = &quot;uartclk&quot;, &quot;apb_pclk&quot;;
                        };

&lt;span class=&quot;gd&quot;&gt;-                       v2m_serial3: uart@c000 {
-                               compatible = &quot;arm,pl011&quot;, &quot;arm,primecell&quot;;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+                       zzz_i2c_eprom: zzz_i2c_eprom@c000 {
+                               compatible = &quot;zzz-i2c-eprom&quot;;
&lt;/span&gt;                                reg = &amp;lt;0x0c000 0x1000&amp;gt;;
                                interrupts = &amp;lt;8&amp;gt;;
                                clocks = &amp;lt;&amp;amp;v2m_oscclk2&amp;gt;, &amp;lt;&amp;amp;smbclk&amp;gt;;
&lt;span class=&quot;gh&quot;&gt;diff --git a/arch/arm/boot/dts/vexpress-v2p-ca9.dts b/arch/arm/boot/dts/vexpress-v2p-ca9.dts
index 5814460..98206c0 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/arch/arm/boot/dts/vexpress-v2p-ca9.dts
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/arch/arm/boot/dts/vexpress-v2p-ca9.dts
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -25,7 +25,6 @@
&lt;/span&gt;                serial0 = &amp;amp;v2m_serial0;
                serial1 = &amp;amp;v2m_serial1;
                serial2 = &amp;amp;v2m_serial2;
&lt;span class=&quot;gd&quot;&gt;-               serial3 = &amp;amp;v2m_serial3;
&lt;/span&gt;                i2c0 = &amp;amp;v2m_i2c_dvi;
                i2c1 = &amp;amp;v2m_i2c_pcie;
        };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;At this point we can (and should) build Linux and boot to note that it finds
one serial port less. Next letâ€™s turn our attention to QEMU where we apply the
following change&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/hw/arm/vexpress.c b/hw/arm/vexpress.c
index 9fad791..c1f7550 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/hw/arm/vexpress.c
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/hw/arm/vexpress.c
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -625,7 +625,11 @@ static void vexpress_common_init(MachineState *machine)
&lt;/span&gt;     pl011_create(map[VE_UART0], pic[5], serial_hds[0]);
     pl011_create(map[VE_UART1], pic[6], serial_hds[1]);
     pl011_create(map[VE_UART2], pic[7], serial_hds[2]);
&lt;span class=&quot;gi&quot;&gt;+#if 0
&lt;/span&gt;     pl011_create(map[VE_UART3], pic[8], serial_hds[3]);
&lt;span class=&quot;gi&quot;&gt;+#else
&lt;/span&gt;     sysbus_create_simple(&quot;axi_master_client_device&quot;, map[VE_UART3], pic[8]);
&lt;span class=&quot;gi&quot;&gt;+#endif
&lt;/span&gt;
     sysbus_create_simple(&quot;sp804&quot;, map[VE_TIMER01], pic[2]);
     sysbus_create_simple(&quot;sp804&quot;, map[VE_TIMER23], pic[3]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;i.e. we map our device to the same address and interrupt as where the fourth
UART used to be.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;
&lt;p&gt;In RTL the I2C controller has been extended with an IRQ line that asserts
whenever the controller state machine goes from a non-idle state to idle (i.e.
it has just finished work). An AXI mapped register has also been added that,
when written to, de-asserts the IRQ line.&lt;/p&gt;

&lt;p&gt;Since our RTL simulation is not that tightly tied into QEMU (and there is some
delay between a de-assert write and the de-asserted IRQ line finds its way back
into QEMU) we are going to use the IRQ line as &lt;em&gt;edge triggered&lt;/em&gt; to avoid
problems with the ISR falsely triggering.&lt;/p&gt;

&lt;p&gt;After rebuilding QEMU and Linux (as described in previous posts) we can now
focus our attention on the actual device driver
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/linux/i2c-eprom-driver-irq.c&quot;&gt;linux/i2c-eprom-driver-irq.c&lt;/a&gt;.
I would say that it differs from the previous attempt in the following ways&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Registers as a &lt;em&gt;platform driver&lt;/em&gt; and as such only gets called for &lt;em&gt;device
tree&lt;/em&gt; entries that match the given compatibility string&lt;/li&gt;
  &lt;li&gt;Gets the interrupt number and mapped memory range from the &lt;em&gt;device tree&lt;/em&gt; (see
probe function)&lt;/li&gt;
  &lt;li&gt;State machine inside interrupt handler&lt;/li&gt;
  &lt;li&gt;Wait queues to block user process while waiting for a file operation to
finish&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;During operation the &lt;em&gt;dev_read&lt;/em&gt;/&lt;em&gt;dev_write&lt;/em&gt; function does the first register
write to the I2C controller and then puts itself on a wait queue. The state
machine in the ISR will do the remaining register writes to the controller one
at a time. When the last operation has finished the ISR wakes up the sleeping
process.&lt;/p&gt;

&lt;p&gt;The wait queue handling deserves some further explanation as to why we cannot
use the more convenient &lt;em&gt;wait_event_interruptible&lt;/em&gt; and instead have to expanded
the sequence as follows.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prepare_to_wait(&amp;amp;wq, &amp;amp;wait, TASK_INTERRUPTIBLE);
/* I2C address device for write mode */
state = S_WRITE_1;
axi_master_write(i2c_ctrl_addr, i2c_ctrl_we_bit | i2c_ctrl_start_bit | I2C_ADDR &amp;lt;&amp;lt; 1 | 0 &amp;lt;&amp;lt; 0);
schedule();
finish_wait(&amp;amp;wq, &amp;amp;wait);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The reason for this is that we need to write the controller command (that will
eventually generate the interrupt so that our ISR wakes us up) before we go to
sleep. However if we for some reason got delayed at the point after the
controller write but before entering our sleep we could have a situation where
the ISR signals us to wake up before we have gone to sleep and then, when we
actually do go to sleep, there will be no ISR to wake us up.&lt;/p&gt;

&lt;p&gt;To deal with this situation it is a common pattern to mark ourselves as
sleeping with the &lt;em&gt;prepare_to_wait&lt;/em&gt; call, then do the controller write and
finally yield with a call to &lt;em&gt;schedule&lt;/em&gt;. This way there is no harm if the ISR
wakes us up before yielding.&lt;/p&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h2&gt;
&lt;p&gt;Now there are certainly more improvements that could be made to the driver and
especially in the area of concurrent access to the device but I think that we
are going to be happy with the current state for this post. To be honest the
driver for this device feels a bit contrived and I would rather revisit this
topic with a more realistic device (e.g. some sort of communications device
with ring buffers for rx and tx).&lt;/p&gt;

&lt;p&gt;Did you like this post? Questions or feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">Now we are going to revisit the device driver from part 3 of this series and redo it properly.</summary></entry><entry><title type="html">A basic I2C controller - part 3</title><link href="https://www.zzzconsulting.se/2018/07/19/i2c-controller-part-3.html" rel="alternate" type="text/html" title="A basic I2C controller - part 3" /><published>2018-07-19T00:00:00+02:00</published><updated>2018-07-19T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/07/19/i2c-controller-part-3</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/07/19/i2c-controller-part-3.html">&lt;p&gt;In todayâ€™s post we will start writing a Linux device driver for our simulated
I2C EPROM. It will be a simple character device that shows up as &lt;em&gt;/dev/zzz-i2c-eprom&lt;/em&gt;
and allows data to be read and written as in&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo &quot;Hello EPROM!&quot; &amp;gt; /dev/zzz-i2c-eprom
cat /dev/zzz-i2c-eprom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;interrupts&quot;&gt;Interrupts&lt;/h2&gt;
&lt;p&gt;Since I2C is slow and we do not want to busy-wait on the status register inside
the driver (we actually could if we kept calling &lt;em&gt;schedule()&lt;/em&gt; but lets try to
do it properly) we need to generate a interrupt from the block once the busy
status de-asserts.&lt;/p&gt;

&lt;p&gt;Generating asynchronous signals from the block poses a problem for our current
socket based simulation system as it is totally synchronous and everything is
initiated from the QEMU side.&lt;/p&gt;

&lt;p&gt;To deal with the asynchronous nature of interrupts we are going to introduce a
second socket on which the VPI code can post interrupt requests. In our QEMU
device we will create a thread that blocks on a receive on this socket and once
a IRQ arrives it will acquire the &lt;em&gt;Big QEMU Lock&lt;/em&gt; and pass the IRQ on to the
QEMU internals.&lt;/p&gt;

&lt;h2 id=&quot;problems&quot;&gt;Problems&lt;/h2&gt;
&lt;p&gt;Unfortunately it turns out that getting an interrupt mapped through Linux in
modern days is a bit more difficult than I expected. Seemingly to get this
machinery to play along nicely with us we will have to do it the real proper
way using the &lt;em&gt;platform device&lt;/em&gt; framework and adding &lt;em&gt;device tree (DTS)&lt;/em&gt;
entries. Doing so will quite frankly require a bit of read up from my side so
we will postpone that to the next post in this series. For now letâ€™s just do it
the busy-wait way and verify that everything works.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;
&lt;p&gt;Now that we got that out of the way letâ€™s get started with our device driver.
We are going to implement it as an out-of-tree kernel module as it simplifies
building.&lt;/p&gt;

&lt;p&gt;The code for the non-interrupt driven device driver can be found in
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/linux/i2c-eprom-driver.c&quot;&gt;linux/i2c-eprom-driver.c&lt;/a&gt;.
Notice that we are reusing a lot of code from
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/axi_master_client.c&quot;&gt;axi_master_client.c&lt;/a&gt;
from the first post.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT/i2c-controller/linux
make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm -C $ZZZ_ROOT/linux M=${PWD} modules
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;After building the driver be sure to remember to copy the resulting
&lt;em&gt;i2c-eprom-driver.ko&lt;/em&gt; to the BusyBox file system and rebuild the image&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp $ZZZ_ROOT/i2c-controller/linux/i2c-eprom-driver.ko $ZZZ_ROOT/busybox/_install/
pushd $ZZZ_ROOT/busybox/_install
find . -print0 | cpio --null -ov --format=newc | gzip -9 &amp;gt; $ZZZ_ROOT/initramfs.cpio.gz
popd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;
&lt;p&gt;Once built and moved to the BusyBox filesystem the module installs as follows
into our running Linux system&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;insmod i2c-eprom-driver.ko
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Since we already setup the BusyBox hotplug daemon &lt;em&gt;mdev&lt;/em&gt; in the previous post
the device file &lt;em&gt;/dev/zzz-i2c-eprom&lt;/em&gt; should automatically appear in the file
system once the module is installed.&lt;/p&gt;

&lt;p&gt;Now we can finally try out the full system! Letâ€™s start by clearing the memory
with zeros, then write some string into it and verify that it reads back.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dd if=/dev/zero of=/dev/zzz-i2c-eprom count=16 bs=1
echo &quot;Hello world!!!&quot; &amp;gt; /dev/zzz-i2c-eprom
cat /dev/zzz-i2c-eprom
echo -n &quot;J&quot; &amp;gt; /dev/zzz-i2c-eprom
cat /dev/zzz-i2c-eprom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h2&gt;
&lt;p&gt;And there we have it, a complete simulation chain from custom RTL to a Linux
device driver. In my opinion this is pretty cool and the best thing of all is
that it does not use any pesky proprietary software or vendor branches.&lt;/p&gt;

&lt;p&gt;In the next post we will be looking at the interrupt mapping and improving the
device driver.&lt;/p&gt;

&lt;p&gt;Did you like this post? Questions or feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">In todayâ€™s post we will start writing a Linux device driver for our simulated I2C EPROM. It will be a simple character device that shows up as /dev/zzz-i2c-eprom and allows data to be read and written as in</summary></entry><entry><title type="html">A basic I2C controller - part 2</title><link href="https://www.zzzconsulting.se/2018/07/18/i2c-controller-part-2.html" rel="alternate" type="text/html" title="A basic I2C controller - part 2" /><published>2018-07-18T00:00:00+02:00</published><updated>2018-07-18T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/07/18/i2c-controller-part-2</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/07/18/i2c-controller-part-2.html">&lt;p&gt;In this post we will integrate our I2C controller simulation with QEMU. If
you didnâ€™t already know &lt;a href=&quot;https://en.wikipedia.org/wiki/QEMU&quot;&gt;QEMU&lt;/a&gt; is a free and
open-source emulator that performs hardware virtualization. More specifically
it will allow us to emulate an ARM system where we can connect our I2C
controller as a memory mapped device. We are going to pick the ARM
VersatileExpress development board, that is already emulated by QEMU, and
modify it by adding our device.&lt;/p&gt;

&lt;h2 id=&quot;get-modify-and-build-qemu&quot;&gt;Get, modify and build QEMU&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT
wget https://download.qemu.org/qemu-2.12.0.tar.xz
tar xf qemu-2.12.0.tar.xz
mkdir qemu-build
cd $ZZZ_ROOT/qemu-build
../qemu-2.12.0/configure --prefix=$ZZZ_ROOT/qemu-install
make install -j8
export PATH=$ZZZ_ROOT/qemu-install/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To register our device we need to add the following line to the
&lt;em&gt;a9_daughterboard_init&lt;/em&gt; function of &lt;em&gt;qemu-2.12.0/hw/arm/vexpress.c&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sysbus_create_simple(&quot;axi_master_client_device&quot;, 0x1e00b000, NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;For the actual implementation of our device
(&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/qemu/axi_master_client_device.c&quot;&gt;qemu/axi_master_client_device.c&lt;/a&gt;)
I simply sym-linked to it, and remembered to update the &lt;em&gt;hw/arm/Makefile.objs&lt;/em&gt;
so that it gets built. As can be seen adding a memory mapped device to an ARM
based QEMU system turned out to be rather straight forward and all we really
needed to do was to implement one hook for memory reads and one hook for memory
writes to our region.&lt;/p&gt;

&lt;h2 id=&quot;prepare-the-linux-system&quot;&gt;Prepare the Linux system&lt;/h2&gt;
&lt;p&gt;Second we are going to go ahead and build a complete little Linux system
(kernel and busybox file system). While it is strictly not needed for what we
are trying to achieve in this post it will be convenient to have for testing as
you will see shortly.&lt;/p&gt;

&lt;p&gt;Before we do anything we need to make sure that we have a usable cross compiler
for our intended target. I grabbed a pre-built one from
&lt;a href=&quot;https://releases.linaro.org/components/toolchain/binaries/latest-6/arm-linux-gnueabihf/&quot;&gt;here&lt;/a&gt;.
Then we need to acquire and build the kernel sources&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT
wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.17.8.tar.xz
tar xf linux-4.17.8.tar.xz
ln -s linux-4.17.8 linux
cd $ZZZ_ROOT/linux
make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm vexpress_defconfig
make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm -j8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;After that BusyBox&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT
wget http://busybox.net/downloads/busybox-1.29.1.tar.bz2
tar xf busybox-1.29.1.tar.bz2
ln -s busybox-1.29.1 busybox
cd $ZZZ_ROOT/busybox
make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm defconfig
make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm menuconfig (enable static link option)
make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm -j8 install
cd _install
mkdir proc sys dev etc etc/init.d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;put the following lines in etc/init.d/rcS&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
mount &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; proc none /proc
mount &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; sysfs none /sys
mount &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; debugfs none /sys/kernel/debug/
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; /sbin/mdev &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /proc/sys/kernel/hotplug
/sbin/mdev &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and make it executable&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chmod +x etc/init.d/rcS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;now finally create the file system image&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pushd $ZZZ_ROOT/busybox/_install
find . -print0 | cpio --null -ov --format=newc | gzip -9 &amp;gt; $ZZZ_ROOT/initramfs.cpio.gz
popd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;

&lt;h3 id=&quot;linux-boot&quot;&gt;Linux boot&lt;/h3&gt;
&lt;p&gt;First let us boot up the Linux system&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qemu-system-arm -M vexpress-a9 -kernel $ZZZ_ROOT/linux/arch/arm/boot/zImage -dtb $ZZZ_ROOT/linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -initrd $ZZZ_ROOT/initramfs.cpio.gz -append &quot;console=ttyAMA0 ignore_loglevel log_buf_len=10M print_fatal_signals=1 LOGLEVEL=8 earlyprintk=vga,keep sched_debug root=/dev/ram rdinit=/sbin/init&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;QEMU has a monitor that can be entered by issuing &lt;strong&gt;ctrl-a c&lt;/strong&gt;. There is also a
shorthand for the very useful quit command by pressing &lt;strong&gt;ctrl-a x&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;At this point just verify that the Linux system boots up and that you can enter
the BusyBox shell.&lt;/p&gt;

&lt;h3 id=&quot;the-qemu-and-axi-part&quot;&gt;The QEMU and AXI part&lt;/h3&gt;
&lt;p&gt;BusyBox has a very convenient utility command called &lt;em&gt;devmem&lt;/em&gt; that allows us to
access physical memory addresses without the hassle of having to write a kernel
module at this point, or having to write a custom user space program to fiddle
with &lt;em&gt;/dev/mem&lt;/em&gt; for that matter (since that is exactly what &lt;em&gt;devmem&lt;/em&gt; does).&lt;/p&gt;

&lt;p&gt;The AXI slave of our I2C controller implements a few dummy registers (they can
be written and read but serve no other purpose) that we can use to verify our
system. The three registers are mapped at 0x1e00b000, 0x1e00b004 and
0x1e00b008.&lt;/p&gt;

&lt;p&gt;First start the RTL simulation with AXI master server&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vvp -M. -mvpi_axi_master i2c.vvp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Then start the QEMU system (as described above) and use &lt;em&gt;devmem&lt;/em&gt; to fire away a
few writes and verify that the values read back are as expected.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;devmem 0x1e00b000 w 0x11112222
devmem 0x1e00b004 w 0x33334444
devmem 0x1e00b008 w 0x55556666

devmem 0x1e00b004
devmem 0x1e00b000
devmem 0x1e00b008
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Note that we already verified that the I2C controller was working reasonably
well in the previous post so we can delay further testing of that until the
next post where we implement a proper device driver.&lt;/p&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h2&gt;
&lt;p&gt;That concludes todayâ€™s post. As always the interesting details are in the code
so be sure to check it out.&lt;/p&gt;

&lt;p&gt;Did you like this post? Questions or feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">In this post we will integrate our I2C controller simulation with QEMU. If you didnâ€™t already know QEMU is a free and open-source emulator that performs hardware virtualization. More specifically it will allow us to emulate an ARM system where we can connect our I2C controller as a memory mapped device. We are going to pick the ARM VersatileExpress development board, that is already emulated by QEMU, and modify it by adding our device.</summary></entry><entry><title type="html">A basic I2C controller - part 1</title><link href="https://www.zzzconsulting.se/2018/07/17/i2c-controller-part-1.html" rel="alternate" type="text/html" title="A basic I2C controller - part 1" /><published>2018-07-17T00:00:00+02:00</published><updated>2018-07-17T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/07/17/i2c-controller-part-1</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/07/17/i2c-controller-part-1.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;I2C is this two wire bus protocol that is very common in the embedded sphere
and the reader is most likely already familiar with it so the introduction here
will be brief.  As the name suggests it is a protocol for communicating between
ICs and the specification for the protocol can be found
&lt;a href=&quot;http://cache.nxp.com/documents/user_manual/UM10204.pdf&quot;&gt;here&lt;/a&gt;.  The two wires
consist of a clock (SCL) and a data (SDA), the master is responsible for
initiating all transactions. Since it is a bit more complicated than just a
shift-register there are special rules for when &lt;em&gt;SDA&lt;/em&gt; transitions may occur
with respect to &lt;em&gt;SCL&lt;/em&gt; (i.e. not just data sampled at rising edge of clk
end-of-story). For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A SDA 1 -&amp;gt; 0 transition when SCL is high signals a START condition&lt;/li&gt;
  &lt;li&gt;A SDA 0 -&amp;gt; 1 transition when SCL is high signals a STOP condition&lt;/li&gt;
  &lt;li&gt;SDA transitions when SCL is low are used for normal data signaling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course there are more details to it but you can read all about those in the
spec above.&lt;/p&gt;

&lt;p&gt;In this post we are going to outline the RTL (Verilog) implementation and
simulation of a basic I2C controller that connects to a host as an AXI slave. In
future posts we will connect the simulation with QEMU and finish it all up by
writing a Linux device driver.&lt;/p&gt;

&lt;h2 id=&quot;preparations&quot;&gt;Preparations&lt;/h2&gt;
&lt;p&gt;To follow along the reader is urged to acquire the following packages (Verilog
simulator and waveform viewer)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install iverilog gtkwave
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;As always with these things a lot of commands will be issued and a lot of paths
will be used so in an attempt to keep the commands copy-pastable (without the
reader having to manually modify the paths all the time) we are going to
introduce the following environment variable and use that as much as possible
through out the posts&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ZZZ_ROOT=some/path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now let us begin by checking out the Git repository
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller&quot;&gt;https://github.com/markus-zzz/i2c-controller&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT
git clone https://github.com/markus-zzz/i2c-controller
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;It should be noted that a single repository and single branch is used for the
entire post series so some of the files may contain code that will first be
relevant for the later posts.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;
&lt;p&gt;After some thinking I decided that the AXI interface of my simple I2C
controller should expose these two registers&lt;/p&gt;

&lt;h4 id=&quot;control-register&quot;&gt;Control register&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Field&lt;/th&gt;
      &lt;th&gt;Bits&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;we&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Write enable i.e. should we be driving the SDA during the transaction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;start&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Generate start condition before&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;stop&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Generate stop condition after&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;byte&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Data byte to write (could be address in which case the 8:th bit indicates read or write during following transaction)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;status-and-read-register&quot;&gt;Status (and read) register&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Field&lt;/th&gt;
      &lt;th&gt;Bits&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;busy&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Controller busy with ongoing transaction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ack&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Acknowledge status for last transaction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;byte&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Data byte read if last transaction was read (we always sample data even if we are driving SDA ourselves)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If one thinks a bit more about the signaling one realises that dividing the SCL
into four phases might be a good idea so we use a clock enable scheme as
follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// I2C clocking scheme
//
//        -+                             +-----------------------------+
// SCL     |                             |                             |
//         +-----------------------------+                             +-
//
//        -+            +-+            +-+            +-+            +-+
// 4x_en   |            | |            | |            | |            | |
//         +------------+ +------------+ +------------+ +------------+ +-
//
// phase      2'b00          2'b01          2'b10          2'b11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In other words we use the same clock domain as the AXI bus and â€˜divideâ€™ the clock
locally by producing a clock enable signal with four pulses per &lt;em&gt;SCL&lt;/em&gt; period. For
each pulse we increment the two bit phase counter that is used by the remainder
of the design.&lt;/p&gt;

&lt;p&gt;The implementation of the controller is in
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/i2c_controller.v&quot;&gt;i2c_controller.v&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Next thing we need to wrap an AXI slave interface around the controller and
that can be seen in
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/i2c_axi_slave.v&quot;&gt;i2c_axi_slave.v&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;simulation&quot;&gt;Simulation&lt;/h2&gt;
&lt;p&gt;For testing I found
&lt;a href=&quot;https://github.com/olofk/i2c/blob/master/bench/verilog/i2c_slave_model.v&quot;&gt;this&lt;/a&gt;
slave model of a I2C EPROM.&lt;/p&gt;

&lt;p&gt;Now if you think about the amount of AXI signaling that would be required to
write and read something from the EPROM model you quickly realise that it would
be a pain to write all that in plain Verilog. In fact it would be much easier
if we could write all this in a programming language like C and luckily thanks
to VPI (Verilog Procedural Interface) this is a straight forward task.&lt;/p&gt;

&lt;p&gt;Using VPI we connect a callback on value change events for the AXI clock signal
and from there we can manipulate the remainder of the bus signals. We have a
simple software driven state machine that, in its idle state, receives commands
from a socket and, whether it was a read or a write, drives the bus signals
accordingly.&lt;/p&gt;

&lt;p&gt;Now performing AXI reads and writes in our simulation is a simple matter of
sending the appropriate command packet over the socket and by so we have
achieved a reasonable separation between our simulation environment and the bus
interface to it.&lt;/p&gt;

&lt;p&gt;The attentive reader might realise that the approach of having the RTL
simulator block on a socket inside the value change callback for the AXI clock
will effectively block the simulation unless it is constantly being fed with
command packets over the socket. As a lucky coincidence this stream of socket
commands is exactly what happens in the test suite used in this post as it
constantly busy-waits on the status register after each write to the control
register.&lt;/p&gt;

&lt;p&gt;Later on though when we use QEMU and a proper interrupt driven device driver
this will present a problem so we might as well try to solve it now. On the
opposite side of blocking we could do the receive in non-blocking mode and
effectively have the RTL simulation running at full speed all the time. While
this would be functionally correct it is somewhat undesirable since it would be
a huge wast of simulation cycles (and possibly producing some huge dump.vcd
files).&lt;/p&gt;

&lt;p&gt;A better approach is to do a bit of both with the concept of a clock request
signal from the block (we can use the busy bit of the status register for this
purpose). While the block is busy it needs a clock to finish (and become ready)
and in this state we use a non-blocking receive. On the other hand when the
block is ready it is safe to fall back on blocking receives as there is no work
to do until we get a command from the AXI.&lt;/p&gt;

&lt;p&gt;To try it all out simply do&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $ZZZ_ROOT/i2c-controller
./build-all.sh
./run-all.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If all went well this should have executed the test code in
&lt;a href=&quot;https://github.com/markus-zzz/i2c-controller/blob/master/axi_master_client.c&quot;&gt;axi_master_client.c&lt;/a&gt;
writing patterns to the I2C connected memory and then reading back and
verifying.&lt;/p&gt;

&lt;p&gt;To really see what is going on this might be a good opertunity to bring up the
waveform viewer and inspect the signals in &lt;em&gt;tb.dut&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gtkwave dump.vcd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In the next post we try to integrate our socket based model with QEMU and later
on in a third post we will attempt to write a Linux device driver for the
EPROM.&lt;/p&gt;

&lt;p&gt;Did you like this post? Questions or feedback - leave a comment below!&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction I2C is this two wire bus protocol that is very common in the embedded sphere and the reader is most likely already familiar with it so the introduction here will be brief. As the name suggests it is a protocol for communicating between ICs and the specification for the protocol can be found here. The two wires consist of a clock (SCL) and a data (SDA), the master is responsible for initiating all transactions. Since it is a bit more complicated than just a shift-register there are special rules for when SDA transitions may occur with respect to SCL (i.e. not just data sampled at rising edge of clk end-of-story). For example:</summary></entry><entry><title type="html">An LLVM exercise</title><link href="https://www.zzzconsulting.se/2018/07/16/llvm-exercise.html" rel="alternate" type="text/html" title="An LLVM exercise" /><published>2018-07-16T00:00:00+02:00</published><updated>2018-07-16T00:00:00+02:00</updated><id>https://www.zzzconsulting.se/2018/07/16/llvm-exercise</id><content type="html" xml:base="https://www.zzzconsulting.se/2018/07/16/llvm-exercise.html">&lt;p&gt;Letâ€™s write an LLVM optimization pass to familiarize ourselves with the
environment. Of course LLVM already does everything even remotely interesting
so in order to have some non-trivial example we are going to replace an
existing pass. The pass of choice is going to be &lt;em&gt;mem2reg&lt;/em&gt; mainly because it is
quite central and I happen to have experience implementing this very pass in a
different compiler framework.&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;
&lt;p&gt;One interesting thing about LLVM is its approach to entering SSA-form (i.e.
satisfying the static single assignment condition by placement of phi-nodes).
Traditionally this is considered a front end responsibility to place phi-nodes
but LLVM takes a different approach. Namely have the front end generate an
alloca for each variable then loads for the uses and stores for the defs.  Note
that technically speaking this code is already in SSA form (it is just that it
is terribly inefficient). Later on the pass &lt;em&gt;mem2reg&lt;/em&gt; comes along and optimizes
this effectively removing the inefficient memory accesses for these variables.&lt;/p&gt;

&lt;p&gt;This is nice because it makes the front end simpler, it can focus on its AST to
IR translation without additional complexities. On the downside you could argue
that it makes the compilation process inefficient because you have the front
end generate a bunch of IR that will almost immediately be optimized away in
the middle end. In my opinion though that is the name of the game in compiler
engineering, to not worrying about everything at once but instead have each
part do one thing well and have an efficient IR infrastructure that allows for
cheap IR updates.&lt;/p&gt;

&lt;h2 id=&quot;prerequisites&quot;&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;To follow along you will need to have an LLVM development environment setup.
This is all pretty well described
&lt;a href=&quot;https://llvm.org/docs/GettingStarted.html&quot;&gt;here&lt;/a&gt; but in short this is what I
did&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ROOT=&amp;lt;some path&amp;gt;
export PATH=$ROOT/install/bin:$PATH
mkdir -p $ROOT
mkdir -p $ROOT/build
mkdir -p $ROOT/install
cd $ROOT
wget http://releases.llvm.org/6.0.1/llvm-6.0.1.src.tar.xz
wget http://releases.llvm.org/6.0.1/cfe-6.0.1.src.tar.xz
tar xf llvm-6.0.1.src.tar.xz
cd $ROOT/llvm-6.0.1.src/tools/
tar xf $ROOT/cfe-6.0.1.src.tar.xz
cd $ROOT/build
cmake -G Ninja $ROOT/llvm-6.0.1.src/ -DCMAKE_INSTALL_PREFIX=$ROOT/install -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON -DLLVM_TARGETS_TO_BUILD=&quot;ARM&quot;
ninja install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;experiment&quot;&gt;Experiment&lt;/h2&gt;
&lt;p&gt;Let us start by looking at the LLVM IR before and after &lt;em&gt;mem2reg&lt;/em&gt; for the following example&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Invoking the front end and emitting IR without applying any optimizations is as simple as&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang -target armv7h -mfloat-abi=hard sum.c -O0 -S -emit-llvm -o sum.ll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define arm_aapcs_vfpcc i32 @sum(i32* %data, i32 %len) #0 {
entry:
  %data.addr = alloca i32*, align 4
  %len.addr = alloca i32, align 4
  %s = alloca i32, align 4
  %i = alloca i32, align 4
  store i32* %data, i32** %data.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  store i32 0, i32* %s, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %len.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32*, i32** %data.addr, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %2, i32 %3
  %4 = load i32, i32* %arrayidx, align 4
  %5 = load i32, i32* %s, align 4
  %add = add nsw i32 %5, %4
  store i32 %add, i32* %s, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, i32* %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %7 = load i32, i32* %s, align 4
  ret i32 %7
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Then running the standard &lt;em&gt;mem2reg&lt;/em&gt; pass on this IR&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;opt -passes mem2reg -S sum.ll -o sum-mem2reg.ll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define arm_aapcs_vfpcc i32 @sum(i32* %data, i32 %len) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %s.0 = phi i32 [ 0, %entry ], [ %add, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, %len
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %data, i32 %i.0
  %0 = load i32, i32* %arrayidx, align 4
  %add = add nsw i32 %s.0, %0
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret i32 %s.0
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;As can be seen the effects of the &lt;em&gt;mem2reg&lt;/em&gt; pass are rather dramatic. Gone are the
inefficient variable &lt;em&gt;loads&lt;/em&gt;, &lt;em&gt;stores&lt;/em&gt; and &lt;em&gt;alloca&lt;/em&gt; instructions.&lt;/p&gt;

&lt;h2 id=&quot;implement-our-own&quot;&gt;Implement our own&lt;/h2&gt;
&lt;p&gt;Now letâ€™s implement our own &lt;em&gt;mem2reg&lt;/em&gt; pass (and call it &lt;em&gt;ourmem2reg&lt;/em&gt;) and see if we
can achieve similar results. The algoritm we will use will be the classical one
by Cytron et al. and the interested reader can find all the details in [1].&lt;/p&gt;

&lt;p&gt;The basics of writing an LLVM pass are described
&lt;a href=&quot;http://llvm.org/docs/WritingAnLLVMPass.html&quot;&gt;here&lt;/a&gt;. Pay special attention to
the section about setting up the build environment to build the pass as a
loadable module. Doing so will save a lot of pain.&lt;/p&gt;

&lt;p&gt;I went ahead and wrote &lt;a href=&quot;https://www.zzzconsulting.se/download/OurMem2Reg.cpp&quot;&gt;OurMem2Reg.cpp&lt;/a&gt;
and will now try to describe its contents in some detail.&lt;/p&gt;

&lt;h3 id=&quot;linkdefsandusestovar&quot;&gt;linkDefsAndUsesToVar&lt;/h3&gt;
&lt;p&gt;Given a variable (i.e. an alloca) we need to find the definitions and uses of
this variable. This corresponds to finding the store and load instructions that
use the alloca as an address. We also need to make sure that these are the only
uses of the alloca i.e. the address does not escape and allow for potential
modifictaion else where.&lt;/p&gt;

&lt;h3 id=&quot;renamerecursive&quot;&gt;renameRecursive&lt;/h3&gt;
&lt;p&gt;Here we walk the dominator tree and perform a pre-order action and a post-order action.&lt;/p&gt;
&lt;h4 id=&quot;pre-order-action&quot;&gt;Pre-order action&lt;/h4&gt;
&lt;p&gt;Scan for def and use instructions in the block and maintain a definition stack
for each variable. A use (i.e. a load instruction) get replaced by the value on
top of the definition stack and a def (store instruction) pushes the value
stored onto the stack.&lt;/p&gt;
&lt;h4 id=&quot;post-order-action&quot;&gt;Post-order action&lt;/h4&gt;
&lt;p&gt;For the post-order action we need to pop the definitions put on the stack once
we are done at a level in the dominator tree and about to move up. Obviously
once we are done with a block and all the blocks that are dominated by it we
need to remove the variable definitions that came from that block since they
are no longer valid.&lt;/p&gt;

&lt;h3 id=&quot;runonfunction&quot;&gt;runOnFunction&lt;/h3&gt;
&lt;p&gt;The driver of the pass&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Look for &lt;em&gt;alloca&lt;/em&gt; instructions (and according to LLVM conventions they are
all located in the entry block of the function) and call
&lt;em&gt;linkDefsAndUsesToVar&lt;/em&gt; on them to gather information.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In the previous step we took note of in which blocks there were definitions
of the variable. Now we need to insert phi-nodes in the dominance frontier
of these blocks (and keeping in mind that when we insert a phi-node that acts
as a new definition so we need to insert a phi-node in the dominance frontier
of that block as well). In other words we need to insert phi-nodes in the
iterated dominance frontier of the original definition blocks.  Luckily LLVM
has a new fancy framework for computing the iterated dominance frontier set
from a set of definition blocks so we simply use that (if we were to compute it
ourselves I would recommend the method described in [2]).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now we enter the actual work horse of the algorithm - the renaming phase.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The only thing that is left to do now is to remove the trash left behind,
i.e. removing now useless load, store and alloca instructions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;getanalysisusage&quot;&gt;getAnalysisUsage&lt;/h3&gt;
&lt;p&gt;Simply informing the pass manager that we need a valid dominator tree and that
we are not going to make changes to the CFG.&lt;/p&gt;

&lt;h2 id=&quot;evaluate&quot;&gt;Evaluate&lt;/h2&gt;
&lt;p&gt;Running the optimizer with our pass loaded as a module&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;opt -load $ROOT/build/lib/LLVMOurMem2Reg.so -ourmem2reg -S sum.ll -o sum-ourmem2reg.ll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;giving us the following result which looks rather identical to what we get with
the stock &lt;em&gt;mem2reg&lt;/em&gt; pass&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define arm_aapcs_vfpcc i32 @sum(i32* %data, i32 %len) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %1 = phi i32 [ 0, %entry ], [ %add, %for.inc ]
  %cmp = icmp slt i32 %0, %len
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %data, i32 %0
  %2 = load i32, i32* %arrayidx, align 4
  %add = add nsw i32 %1, %2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret i32 %1
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h2&gt;
&lt;p&gt;So what areas of the LLVM infrastructure have we familiarized ourselves with in
this exercise?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Traversing the CFG&lt;/li&gt;
  &lt;li&gt;Traversing the SSA graph (looking for uses of an instruction)&lt;/li&gt;
  &lt;li&gt;Requesting a dominator tree and traversing it&lt;/li&gt;
  &lt;li&gt;Using the iterated dominance frontier machinery&lt;/li&gt;
  &lt;li&gt;Replacing instructions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally I make no claim that the pass implemented is 100% correct and there are
surely corner cases that would need to be handled for a proper implementation.
That however was not the purpose of this post but rather to provide an exercise
to familiarize oneself with the LLVM API using a somewhat real example doing
something useful.&lt;/p&gt;

&lt;p&gt;In fact there is one issue if a variable is used before it is defined (e.g. not
initializing the summation variable in the example above) will result in a
compiler crash. Of course using a variable before it is defined is hardly good
practice but the pass should still handle it correctly. Fixing this is left as
an exercise for the reader but it is simply a matter of inserting a undef
instruction if we encounter a use while the definition stack is empty.&lt;/p&gt;

&lt;p&gt;Did you like this post? Questions or feedback - leave a comment below!&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;p&gt;[1] Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth
Zadeck. 1991. Efficiently computing static single assignment form and the
control dependence graph. ACM Trans. Program. Lang. Syst. 13, 4 (October 1991),
451-490. DOI=http://dx.doi.org/10.1145/115372.115320&lt;/p&gt;

&lt;p&gt;[2] Cooper, Keith &amp;amp; Harvey, Timothy &amp;amp; Kennedy, Ken. (2006). A Simple, Fast
Dominance Algorithm. Rice University, CS Technical Report 06-33870.&lt;/p&gt;</content><author><name></name></author><summary type="html">Letâ€™s write an LLVM optimization pass to familiarize ourselves with the environment. Of course LLVM already does everything even remotely interesting so in order to have some non-trivial example we are going to replace an existing pass. The pass of choice is going to be mem2reg mainly because it is quite central and I happen to have experience implementing this very pass in a different compiler framework.</summary></entry></feed>